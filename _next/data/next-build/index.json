{"pageProps":{"list":[{"title":"使用imagemagic制作瓦片地图","body":"之前有个项目客户给一张精度很高的图让做成那种能够缩放的地图的效果。一开始的想法是直接加载大图，然后通过手势去控制图片的scale来实现，后来觉得不妥，高精度图片的体积实在太大，加载时间太长，效果很不好。通过研究发现[openlayers](https://openlayers.org/)这种专门用来加载地图的库才是更好的选择。但是怎么把图片制作成那种瓦片地图是个问题。\r\n\r\n>瓦片地图金字塔模型是一种多分辨率层次模型，从瓦片金字塔的底层到顶层，分辨率越来越低，但表示的地理范围不变。首先确定地图服务平台所要提供的缩放级别的数量N，把缩放级别最高、地图比例尺最大的地图图片作为金字塔的底层，即第0层，并对其进行分块，从地图图片的左上角开始，从左至右、从上到下进行切割，分割成相同大小(比如256x256像素)的正方形地图瓦片，形成第0层瓦片矩阵;在第0层地图图片的基础上，按每像素分割为2×2个像素的方法生成第1层地图图片，并对其进行分块，分割成与下一层相同大小的正方形地图瓦片，形成第1层瓦片矩阵;采用同样的方法生成第2层瓦片矩阵;…;如此下去，直到第N一1层，构成整个瓦片金字塔。\r\n\r\n# 原理\r\n瓦片地图的原理很简单。假设客户给的原图为（512*4，512*4），这是我们地图能够达到的最高分辨率，但是假设我们的视窗只有512*512，此时我们只能看到左上角1/16的部分。假设用户最开始看到的图包含整个地图，也就是512*512，此时地图被缩放了16倍，宽高个4倍，此时设level为1，那么当放大一倍时，此时地图实际图片大小为（512*2，512*2），此时level为2，当再放大一倍时，此时level为3，刚好为原图，分辨率最高。那么我们只要想办法把原图按不同level缩放切割就行。level1就是直接宽高各缩放4倍，level2各缩放2倍，再把它切成4张，每张大小为512*512，level3的时候不用缩放，直接切成16张，同样每张512*512.我们把\r\n不同level的图片放在不同的文件夹下，然后用能够加载瓦片地图的库就能加载，例如openlayers。所以我们剩下的问题就是怎么切图了。\r\n```javascript\r\nimport 'ol/ol.css';\r\nimport Map from 'ol/Map';\r\nimport TileLayer from 'ol/layer/Tile';\r\nimport View from 'ol/View';\r\nimport XYZ from 'ol/source/XYZ';\r\n\r\nvar map = new Map({\r\n  target: 'map',\r\n  layers: [\r\n    new TileLayer({\r\n      source: new XYZ({\r\n        url:\r\n          'https://localhost:9080/tiles/{z}-{x}-{y}.png'    //因为我的图片是 1-1-1这种形式组成所以这里是这样，如果你的图片是按等级放在不同文件夹要写成 https://localhost:9080/tiles/{z}/{x}/{y}.png 具体怎么放要看你如何组织的tiles结构\r\n      }),\r\n    }) ],\r\n  view: new View({\r\n    center: [-472202, 7530279],\r\n    zoom: 12,\r\n  }),\r\n});\r\n```\r\n\r\n<img width=\"967\" alt=\"QQ20210615-225842@2x\" src=\"https://user-images.githubusercontent.com/18588945/122076316-5af83c00-ce2d-11eb-9f5e-b144e416ee1f.png\">\r\n\r\n# 使用imagemagic处理图片\r\n> Use ImageMagick® to create, edit, compose, or convert digital images. It can read and write images in a variety of formats (over 200) including PNG, JPEG, GIF, WebP, HEIC, SVG, PDF, DPX, EXR and TIFF. ImageMagick can resize, flip, mirror, rotate, distort, shear and transform images, adjust image colors, apply various special effects, or draw text, lines, polygons, ellipses and Bézier curves.\r\n\r\n[imagemagic](https://imagemagick.org/index.php)是一个强大的图片处理工具，可以用命令行直接处理图片，可以很方便的实现各种图片处理操作。虽然很强大但不得不说文档很晦涩难懂，我也只是为了完成这个任务熟悉了几个命令而已，完全谈不上精通。\r\n[我们的切图工具分2个步骤，第一步就是按不同level切图，但是因为并不是刚好如原理分析里讲的那么刚好就是整数倍，地图原图往往不是刚好是正方形，比如切的瓦片每个为512*512，切到边上的时候可能只有360*400这样的，这时需要把它补成512*512，不然会有奇怪的现象发生。注意，脚本里有些参数要根据你的实际情况自己设置。[源码地址](https://github.com/gwl002/imagemagicScript)\r\n```bash\r\n#! /bin/bash\r\n#cropFile.sh\r\nINDEX=1\r\nIMAGE_WIDTH=10752   #原图宽度\r\nIMAGE_HEIGHT=21504  #原图高度\r\n\r\nfor file in `ls \"originImages\"`;do #将原图放在orginalImages文件夹下\r\n\techo \"processing ${file}\"\r\n\tfile_base=$(basename $file .png) #拿到原图名称\r\n\ttiles_dir=\"${file_base}_tiles\"   #碰到有无目标文件夹，有则直接下一步，没有就建立文件夹\r\n\tif [ -e \"${tiles_dir}\" ] && [ -d \"${tiles_dir}\" ];then \r\n\t\techo \"${tiles_dir} exisit\"\r\n\telse\r\n\t\techo \"mkdir ${tiles_dir}\"\r\n\t\tmkdir \"${tiles_dir}\"\r\n\t\techo \"mkdir ${tiles_dir} completed\"\r\n\tfi\r\n\tfor (( i=1; i<=7; i++));do    #根据你自己的需求调节所需的等级\r\n\t\techo \"processing ${file} scale ${i}\"\r\n\t\t((level= 7 - i))\r\n\t\t((scale= 2 ** (i-1)))\r\n\t\t((width= $IMAGE_WIDTH / $scale))\r\n\t\t((height= $IMAGE_HEIGHT / $scale))\r\n\t\tresizeFormat=\"${width}x${height}\"\r\n\t\techo $resizeFormat\r\n\t\tconvert \"originImages/${file}\" -resize $resizeFormat -crop 512x512 -set filename:tile ./${tiles_dir}/${level}-%[fx:page.x/512]-%[fx:page.y/512] %[filename:tile].png\r\n\t\techo \"complete ${file} scale ${i}\"\r\n\tdone\r\n\techo \"complete ${file}\"\r\n\tlet INDEX=${INDEX}+1\r\ndone\r\n```\r\n```bash\r\n#! /bin/bash\r\n#fillSize.sh\r\nSTART=`date +%s%N`;\r\nfor folder in `ls | grep \"H*tiles\"`;do  #找到所有之前切片生成的文件夹，遍历其中找到其中尺寸不对的，将其放置在512*512透明图的左上角\r\n\techo $folder\r\n\tfor image in `ls $folder`;do\r\n\t\techo $image\r\n\t\tratio=`identify \"${folder}/${image}\" | cut -d \" \" -f 3`\r\n\t\tif [ \"$ratio\" != \"128x128\" ];then\r\n\t\t\techo $ratio\r\n\t\t\tconvert \"${folder}/${image}\" -background transparent -gravity NorthWest -extent 512x512 \"${folder}/${image}\"\r\n\t\tfi \r\n\tdone\r\ndone\r\nEND=`date +%s%N`;\r\ntime=$((END-START))\r\ntime=`expr $time / 1000000`\r\necho \"totally spend time ${time}\"\r\n```\r\n\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/5","createdAt":"2021-06-15T15:45:09Z","tags":["工作经验"]},{"title":"next-blog","body":"---\r\ndescription: 简单测试front-matter\r\nkeywords: 11\r\n---\r\n测试写一个next-blog","url":"https://github.com/gwl002/gwl002.github.io/issues/4","createdAt":"2021-06-11T02:42:50Z","tags":["react"]},{"title":"rxjs实现贪吃蛇小游戏","body":"本文介绍基于rxjs写一个经典的游戏贪吃蛇的过程。","url":"https://github.com/gwl002/gwl002.github.io/issues/3","createdAt":"2021-06-10T16:15:20Z","tags":["react"]},{"title":"使用javascript生成pdf文件","body":"一个教育网站项目有个需求，需要在学员完成某些测试后生成证书并下载。本以为应该是调用后端的接口生成，但是后端也说不太懂，只好前端来研究一下解决方案。google一下后发现比较靠谱的有2种方案。\r\n\r\n- 使用jspdf和html2canvas这2个库在前端实现\r\n- 使用nodejs通过puppeteer 在后端生成\r\n\r\n下面分别说说这2种方法的实现。\r\n\r\n# 使用jspdf生成pdf\r\n\r\n\r\n首先编写pdf模版的html(我这里是用react写的)。\r\n```jsx\r\n<Cert\r\n    chineseName={chineseName}\r\n    englishName={englishName}\r\n    unitInfo={unitInfo}\r\n/>\r\n```\r\n因为这个模版只是用来生成pdf，并不用显示，所以通过css将其放在视野之外。\r\n```css\r\n.cert {\r\n    width: 870px;\r\n    height: 615px;\r\n    position: absolute;\r\n    // background:transparent url($imgData) ;\r\n    // background-size: 100%;\r\n    // top:-30px;\r\n    left: 5000px;\r\n    visibility: hidden;\r\n    z-index: 99;\r\n}\r\n```\r\n核心代码,先用html2canvas将html转成canvas，再将canvas转成image dataurl，再将image写入pdf中。\r\n```jsx\r\nconst savePDF = async () => {\r\n    setIsLoading(true);\r\n    try {\r\n        const jsPDF = (await import(\"jspdf\")).default; //引入jspdf\r\n        const html2canvas = (await import(\"html2canvas\")).default; //引入html2canvas\r\n        let canvas = await html2canvas(document.querySelector(\"#cert\"), {\r\n            scrollY: 0,  //不设置此属性 滚动视图时会导致下载的pdf有部分不显示\r\n            onclone: (clonedDoc) => {\r\n                clonedDoc.getElementById(\"cert\").style.visibility = 'visible'; //将pdf模版设为可见\r\n            }\r\n        })\r\n        var imgData = canvas.toDataURL('image/png');\r\n        var doc = new jsPDF('l', 'mm', \"a4\", true); \r\n        var width = doc.internal.pageSize.getWidth();\r\n        var height = doc.internal.pageSize.getHeight();\r\n        doc.addImage(imgData, 'PNG', 0, 0, width, height, \"\", \"FAST\"); //FAST 是否压缩\r\n        // let pdf = doc.output('blob');\r\n        // let form = new FormData();\r\n        doc.output('save', 'Certificate.pdf');\r\n    } catch (err) {\r\n        console.log(err);\r\n    } finally {\r\n        setIsLoading(false)\r\n    }\r\n}\r\n```\r\n这就大功告成了？高兴的太早！😭😭😭问题总是层出不穷的多。在用此方法中一共遇到三个较大的问题。\r\n\r\n1. 初步实现功能提交后，一天qa突然和我说怎么生成的pdf上半部分是空白的。没办法，找找找。通过google，发现是html2canvas时会根据用户滚动的位置来计算的，设置scrollY: 0解决。\r\n2. 之前在dev场中测试并没有发现问题，但是上了uat后发现pdf中图片没加载。最后发现是因为uat场图片全部放在了cdn的缘故，pdf不会加载非同源站的图片也就跨域，设置useCORS也没有用。最后直接把pdf中用到的图片换成base64解决。\r\n3. 不同的浏览器和设备生成的pdf文件size不同。有的只有几M,有的十几M。这个应该和设备的分辨率有关。设置了是否压缩，可以调节pdf的size，但是还是无法统一生成的pdf的size。\r\n\r\n# 使用puppeteer后端生成pdf \r\n\r\n做过爬虫的应该都听过鼎鼎大名的phantomjs，当年这个库很火，可以说是一些比较复杂网站的爬虫最终解决方案。因为它可以让你用js操作一个真正的浏览器去访问网站。puppeteer是google推出的headless chrome，可以说是phantomjs的替代品，自从这个库出世，phantomjs好像就停止维护了。\r\n\r\n>  Puppeteer is a Node library which provides a high-level API to control Chrome or Chromium over the DevTools Protocol. Puppeteer runs headless by default, but can be configured to run full (non-headless) Chrome or Chromium.\r\n\r\n为了解决上面说的不同设备生成的pdf size不同的问题，我们可以使用puppeteer来在后端生成pdf。\r\n因为生成的证书如姓名成绩之类的是动态的，所以要用模版动态生成，因为我的项目是react，所以直接用jsx生成模板，用rendertostring生成html字符串。也有一些style和图片处理比较麻烦，可以看我代码，但是这里只是简单实现。\r\n\r\n```jsx\r\nconst PdfTemplate = ({ imgSrc }) => {\r\n    return (\r\n        <div className=\"bg\">\r\n            <h2>heading</h2>\r\n            <div>\r\n                content\r\n            </div>\r\n            <img src={imgSrc} alt=\"\" style={{ width: \"100%\", height: 300 }} />\r\n        </div>\r\n    )\r\n}\r\n\r\nconst createHtmlStr = () => {\r\n    const imagePath = __dirname + \"/../../../../public/images/bg.jpeg\";\r\n    const imgData = fs.readFileSync(imagePath).toString(\"base64\");\r\n    const imgSrc = `data:image/jpeg;base64,${imgData}`;\r\n    const content = ReactDOMServer.renderToString(<PdfTemplate imgSrc={imgSrc} />)\r\n    return `\r\n        <html>\r\n            <head>\r\n                <style>\r\n                    html,body{\r\n                        margin:0;\r\n                        padding:0;\r\n                        height:100%\r\n                    }\r\n                    .bg{\r\n                        height:100%;\r\n                        position:relative;\r\n                    }\r\n                </style>\r\n            </head>\r\n            <body>\r\n                ${content}\r\n            </body>\r\n        </html>\r\n    `\r\n}\r\n```\r\n后端代码\r\n```javascript\r\nexport default async function handler(req, res) {\r\n    console.log(\"start\")\r\n    const browser = await puppeteer.launch({\r\n        args: ['--disable-dev-shm-usage', '--no-sandbox']\r\n    });\r\n    const page = await browser.newPage();\r\n    ;\r\n    const html = createHtmlStr();\r\n    console.log(html, \"====\")\r\n    // await page.goto(\"http://localhost:3000/\");\r\n    await page.setContent(html);\r\n    const pdf = await page.pdf({\r\n        format: 'A4',\r\n        printBackground: true,\r\n        '-webkit-print-color-adjust': 'exact',\r\n    });\r\n    await browser.close();\r\n    console.log(\"end render\");\r\n    res.setHeader(\"Content-Type\", 'application/pdf');\r\n    res.status(200);\r\n    res.send(pdf);\r\n}\r\n\r\n```\r\n前端代码\r\n```javascript\r\n  const downloadPDF = async () => {\r\n          let response = await fetch(\"/api/createPdf\", {\r\n              responseType: 'arraybuffer',\r\n              headers: {\r\n                  'Accept': 'application/pdf'\r\n              }\r\n          });\r\n          let blob = await response.blob();\r\n          // const blob = new Blob([response.body], { type: 'application/pdf' })\r\n          const link = document.createElement('a')\r\n          link.href = window.URL.createObjectURL(blob)\r\n          link.download = `your-file-name.pdf`\r\n          link.click()\r\n  }\r\n```\r\n# 总结\r\n\r\n1. 在前端通过截屏html元素生成pdf，简单方便，不需要后端配合，直接在前端生成pdf，缺点就是生成的pdf文件大小不统一。\r\n2. 在后端用puppeteer生成pdf，可以解决上述方法的问题，但是要引入一个新的接口，需要加一个node服务，这个项目因为我们是用nextjs写的，所以可以很方便的加一个api接口。但是一般我们的后端都是java写的，要额外的开一个node服务不是特别方便。\r\n\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/2","createdAt":"2021-06-06T14:54:27Z","tags":["工作经验"]}],"tags":[{"name":"javascript","color":"1d76db"},{"name":"react","color":"8E26BB"},{"name":"css","color":"F49416"},{"name":"工作经验","color":"bfdadc"}],"title":"暮天云光","subTitle":"工作经验、学习笔记、兴趣爱好"},"__N_SSG":true}