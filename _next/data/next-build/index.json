{"pageProps":{"list":[{"title":"next-blog","body":"测试写一个next-blog","url":"https://github.com/gwl002/gwl002.github.io/issues/4","createdAt":"2021-06-11T02:42:50Z","tags":["react"]},{"title":"rxjs实现贪吃蛇小游戏","body":"本文介绍基于rxjs写一个经典的游戏贪吃蛇的过程。","url":"https://github.com/gwl002/gwl002.github.io/issues/3","createdAt":"2021-06-10T16:15:20Z","tags":["react"]},{"title":"使用javascript生成pdf文件","body":"一个教育网站项目有个需求，需要在学员完成某些测试后生成证书并下载。本以为应该是调用后端的接口生成，但是后端也说不太懂，只好前端来研究一下解决方案。google一下后发现比较靠谱的有2种方案。\r\n\r\n- 使用jspdf和html2canvas这2个库在前端实现\r\n- 使用nodejs通过puppeteer 在后端生成\r\n\r\n下面分别说说这2种方法的实现。\r\n\r\n# 使用jspdf生成pdf <a name=\"使用jspdf生成pdf\"></a>\r\n\r\n首先编写pdf模版的html(我这里是用react写的)。\r\n```jsx\r\n<Cert\r\n    chineseName={chineseName}\r\n    englishName={englishName}\r\n    unitInfo={unitInfo}\r\n/>\r\n```\r\n因为这个模版只是用来生成pdf，并不用显示，所以通过css将其放在视野之外。\r\n```css\r\n.cert {\r\n    width: 870px;\r\n    height: 615px;\r\n    position: absolute;\r\n    // background:transparent url($imgData) ;\r\n    // background-size: 100%;\r\n    // top:-30px;\r\n    left: 5000px;\r\n    visibility: hidden;\r\n    z-index: 99;\r\n}\r\n```\r\n核心代码,先用html2canvas将html转成canvas，再将canvas转成image dataurl，再将image写入pdf中。\r\n```jsx\r\nconst savePDF = async () => {\r\n    setIsLoading(true);\r\n    try {\r\n        const jsPDF = (await import(\"jspdf\")).default; //引入jspdf\r\n        const html2canvas = (await import(\"html2canvas\")).default; //引入html2canvas\r\n        let canvas = await html2canvas(document.querySelector(\"#cert\"), {\r\n            scrollY: 0,  //不设置此属性 滚动视图时会导致下载的pdf有部分不显示\r\n            onclone: (clonedDoc) => {\r\n                clonedDoc.getElementById(\"cert\").style.visibility = 'visible'; //将pdf模版设为可见\r\n            }\r\n        })\r\n        var imgData = canvas.toDataURL('image/png');\r\n        var doc = new jsPDF('l', 'mm', \"a4\", true); \r\n        var width = doc.internal.pageSize.getWidth();\r\n        var height = doc.internal.pageSize.getHeight();\r\n        doc.addImage(imgData, 'PNG', 0, 0, width, height, \"\", \"FAST\"); //FAST 是否压缩\r\n        // let pdf = doc.output('blob');\r\n        // let form = new FormData();\r\n        doc.output('save', 'Certificate.pdf');\r\n    } catch (err) {\r\n        console.log(err);\r\n    } finally {\r\n        setIsLoading(false)\r\n    }\r\n}\r\n```\r\n这就大功告成了？高兴的太早！😭😭😭问题总是层出不穷的多。在用此方法中一共遇到三个较大的问题。\r\n\r\n1. 初步实现功能提交后，一天qa突然和我说怎么生成的pdf上半部分是空白的。没办法，找找找。通过google，发现是html2canvas时会根据用户滚动的位置来计算的，设置scrollY: 0解决。\r\n2. 之前在dev场中测试并没有发现问题，但是上了uat后发现pdf中图片没加载。最后发现是因为uat场图片全部放在了cdn的缘故，pdf不会加载非同源站的图片也就跨域，设置useCORS也没有用。最后直接把pdf中用到的图片换成base64解决。\r\n3. 不同的浏览器和设备生成的pdf文件size不同。有的只有几M,有的十几M。这个应该和设备的分辨率有关。设置了是否压缩，可以调节pdf的size，但是还是无法统一生成的pdf的size。\r\n\r\n# 使用puppeteer后端生成pdf <a name=\"使用puppeteer后端生成pdf \"></a>\r\n\r\n做过爬虫的应该都听过鼎鼎大名的phantomjs，当年这个库很火，可以说是一些比较复杂网站的爬虫最终解决方案。因为它可以让你用js操作一个真正的浏览器去访问网站。puppeteer是google推出的headless chrome，可以说是phantomjs的替代品，自从这个库出世，phantomjs好像就停止维护了。\r\n\r\n>  Puppeteer is a Node library which provides a high-level API to control Chrome or Chromium over the DevTools Protocol. Puppeteer runs headless by default, but can be configured to run full (non-headless) Chrome or Chromium.\r\n\r\n为了解决上面说的不同设备生成的pdf size不同的问题，我们可以使用puppeteer来在后端生成pdf。\r\n因为生成的证书如姓名成绩之类的是动态的，所以要用模版动态生成，因为我的项目是react，所以直接用jsx生成模板，用rendertostring生成html字符串。也有一些style和图片处理比较麻烦，可以看我代码，但是这里只是简单实现。\r\n\r\n```jsx\r\nconst PdfTemplate = ({ imgSrc }) => {\r\n    return (\r\n        <div className=\"bg\">\r\n            <h2>heading</h2>\r\n            <div>\r\n                content\r\n            </div>\r\n            <img src={imgSrc} alt=\"\" style={{ width: \"100%\", height: 300 }} />\r\n        </div>\r\n    )\r\n}\r\n\r\nconst createHtmlStr = () => {\r\n    const imagePath = __dirname + \"/../../../../public/images/bg.jpeg\";\r\n    const imgData = fs.readFileSync(imagePath).toString(\"base64\");\r\n    const imgSrc = `data:image/jpeg;base64,${imgData}`;\r\n    const content = ReactDOMServer.renderToString(<PdfTemplate imgSrc={imgSrc} />)\r\n    return `\r\n        <html>\r\n            <head>\r\n                <style>\r\n                    html,body{\r\n                        margin:0;\r\n                        padding:0;\r\n                        height:100%\r\n                    }\r\n                    .bg{\r\n                        height:100%;\r\n                        position:relative;\r\n                    }\r\n                </style>\r\n            </head>\r\n            <body>\r\n                ${content}\r\n            </body>\r\n        </html>\r\n    `\r\n}\r\n```\r\n后端代码\r\n```javascript\r\nexport default async function handler(req, res) {\r\n    console.log(\"start\")\r\n    const browser = await puppeteer.launch({\r\n        args: ['--disable-dev-shm-usage', '--no-sandbox']\r\n    });\r\n    const page = await browser.newPage();\r\n    ;\r\n    const html = createHtmlStr();\r\n    console.log(html, \"====\")\r\n    // await page.goto(\"http://localhost:3000/\");\r\n    await page.setContent(html);\r\n    const pdf = await page.pdf({\r\n        format: 'A4',\r\n        printBackground: true,\r\n        '-webkit-print-color-adjust': 'exact',\r\n    });\r\n    await browser.close();\r\n    console.log(\"end render\");\r\n    res.setHeader(\"Content-Type\", 'application/pdf');\r\n    res.status(200);\r\n    res.send(pdf);\r\n}\r\n\r\n```\r\n前端代码\r\n```javascript\r\n  const downloadPDF = async () => {\r\n          let response = await fetch(\"/api/createPdf\", {\r\n              responseType: 'arraybuffer',\r\n              headers: {\r\n                  'Accept': 'application/pdf'\r\n              }\r\n          });\r\n          let blob = await response.blob();\r\n          // const blob = new Blob([response.body], { type: 'application/pdf' })\r\n          const link = document.createElement('a')\r\n          link.href = window.URL.createObjectURL(blob)\r\n          link.download = `your-file-name.pdf`\r\n          link.click()\r\n  }\r\n```\r\n# 总结\r\n\r\n1. 在前端通过截屏html元素生成pdf，简单方便，不需要后端配合，直接在前端生成pdf，缺点就是生成的pdf文件大小不统一。\r\n2. 在后端用puppeteer生成pdf，可以解决上述方法的问题，但是要引入一个新的接口，需要加一个node服务，这个项目因为我们是用nextjs写的，所以可以很方便的加一个api接口。但是一般我们的后端都是java写的，要额外的开一个node服务不是特别方便。\r\n\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/2","createdAt":"2021-06-06T14:54:27Z","tags":["css"]}],"tags":[{"name":"javascript","color":"1d76db"},{"name":"react","color":"8E26BB"},{"name":"css","color":"F49416"},{"name":"html","color":"000B87"},{"name":"vue","color":"f9d0c4"}],"title":"暮天云光","subTitle":"工作经验、学习笔记、兴趣爱好"},"__N_SSG":true}