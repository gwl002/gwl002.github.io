{"pageProps":{"title":"rxjs实现贪吃蛇小游戏","body":"初识rxjs感觉惊奇，感觉很多复杂的逻辑好像用rxjs来写变得简单明了。断断续续得学习了一阵子，感觉很好，却一直没有真正在项目中使用过。学习而不使用过不了多久就会忘记，所以这次写一个小demo来加深一下印象。那么写什么好呢，想到以前用react写过贪吃蛇小游戏，据说rxjs很适合用来开发游戏类程序，所以决定用rxjs来写一个经典的贪吃蛇小游戏。\r\n\r\n本文并不介绍rxjs原理和各种操作符的使用，主要解释一下实现的逻辑。推荐几个我经常学习的网站：\r\n\r\n- [30 天精通 RxJS (00)： 關於本系列文章](https://ithelp.ithome.com.tw/articles/10186103) 台湾同胞早年写的教程，写的很好，从原理到使用都讲的很好，还有一些生动的例子，虽然版本和写法已经有些不同，但并不影响学习。\r\n- [官网](https://rxjs.dev/)\r\n- [Learn Rxjs](https://www.learnrxjs.io/)很好的学习网站，每个操作符的解释和例子，以及各种demo。\r\n\r\n# 实现UI\r\n首先看一下整体的界面，包括Board(蛇移动的范围)、Snake(红色）、Food(绿色)、Score(分数)、暂停和重置按钮。这里我们使用react来渲染视图，当然也可以用canvas，我们只注重于逻辑，不关心ui。我们采取数据驱动视图的思维开发，逻辑和页面元素是解耦合，这种思维可以让我们很轻松从react渲染切换到canvas渲染。\r\n\r\n![image](https://user-images.githubusercontent.com/18588945/122550390-291dea00-d066-11eb-8077-2a827aeccc11.png)\r\n\r\n### Board \r\n这个结构是基本不变的，只渲染一次就够了，当然把gameover移除更好，懂react的应该理解为什么用memo。\r\n```jsx\r\n\r\nconst GameOver = ({ isGameOver }) => {\r\n    if (!isGameOver) return null;\r\n    return (\r\n        <h1 className=\"center\">GAME OVER</h1>\r\n    )\r\n}\r\n\r\nconst Board = memo(({ winWidth, size, isGameOver }) => {\r\n    const itemWidth = winWidth / size;\r\n\r\n    const Row = ({ rowIndex }) => {\r\n        return (\r\n            <div className=\"rowContainer\">\r\n                {\r\n                    Array(size).fill().map((item, index) => (\r\n                        <span key={index} className=\"boardItem\" style={{ width: itemWidth, height: itemWidth }}>\r\n                            <span></span>\r\n                        </span>\r\n                    ))\r\n                }\r\n            </div>\r\n        )\r\n    }\r\n\r\n    return (\r\n        <div id=\"board\">\r\n            {\r\n                Array(size).fill().map((item, index) => <Row key={index} />)\r\n            }\r\n            <GameOver isGameOver={isGameOver} />\r\n        </div>\r\n    )\r\n})\r\n```\r\n### Snake 和 Food\r\n```jsx\r\nconst Food = ({ food, itemWidth }) => {\r\n    if (!food) return null;\r\n\r\n    return (\r\n        <span\r\n            className=\"boardItem\"\r\n            style={{\r\n                position: \"absolute\",\r\n                width: itemWidth,\r\n                height: itemWidth,\r\n                left: itemWidth * food.x,\r\n                top: itemWidth * food.y,\r\n                backgroundColor: \"green\"\r\n            }}\r\n        >\r\n            <span></span>\r\n        </span>\r\n    )\r\n\r\n}\r\n\r\nconst Snake = memo(({ data, itemWidth }) => {\r\n    return (\r\n        <>\r\n            {data.map((item, index) =>\r\n                <span\r\n                    // key={`${item.x}-${item.y}`}\r\n                    key={index}\r\n                    className=\"boardItem\"\r\n                    style={{\r\n                        position: \"absolute\",\r\n                        width: itemWidth,\r\n                        height: itemWidth,\r\n                        left: itemWidth * item.x,\r\n                        top: itemWidth * item.y,\r\n                        backgroundColor: \"red\"\r\n                    }}\r\n                >\r\n                    <span></span>\r\n                </span>\r\n            )}\r\n        </>\r\n    )\r\n})\r\n```\r\n### App\r\n把各个组件整合起来\r\n```jsx\r\nconst App = () => {\r\n    const size = 20;\r\n    const [ref, { width }] = useMeasure();\r\n\r\n    const itemWidth = width / size;\r\n\r\n    const initialState = {\r\n        isGameOver: false,\r\n        score: 0,\r\n        snake: [\r\n\r\n        ],\r\n        food: null,\r\n        isPaused: true\r\n    }\r\n\r\n    const [state, setState] = useState(initialState);\r\n\r\n    const renderGame = ([snake, isPaused, food, score, isGameOver]) => {\r\n        setState(state => {\r\n            return {\r\n                ...state,\r\n                snake,\r\n                isPaused,\r\n                food,\r\n                score,\r\n                isGameOver\r\n            }\r\n        })\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <Head>\r\n                <link rel=\"stylesheet\" href=\"/styles/greedySnake.css\" />\r\n            </Head>\r\n            {width > 0 ? null : <Loading />}\r\n            <div className=\"snakeGame\" ref={ref} style={{ visibility: width > 0 ? \"visible\" : \"hidden\" }}>\r\n                <Board winWidth={width} size={size} isGameOver={state.isGameOver} />\r\n                <Snake itemWidth={itemWidth} data={state.snake} />\r\n                <Food itemWidth={itemWidth} food={state.food} />\r\n                <div>\r\n                    <button id=\"pauseORresume\">{\r\n                        state.isPaused ? \"START\" : \"PAUSE\"\r\n                    }</button>\r\n                </div>\r\n                <div>\r\n                    <button id=\"reset\">reset</button>\r\n                </div>\r\n                <span>{state.score}</span>\r\n            </div>\r\n        </>\r\n    )\r\n}\r\n```\r\n现在我们已经实现了基本的页面，接下来我们要做的写游戏的逻辑驱动各元素动起来。\r\n\r\n# 实现游戏的逻辑\r\n\r\n### 逻辑总体分析\r\n首先我们分析renderGame方法，可以看到我们需要snake、food、isPaused、isGameover、score5个值来描述游戏的当前状态。那么我们设立5个流snake\\$、food\\$、isPaused\\$、isGameover\\$、score\\$来描述这5个状态，这5个流任何一个更新我们就重刷游戏的状态。那么现在我们的代码看起来应该是这样的。这里我们使用combineLast来获取每个流的最新值，不懂combineLast的可以先去官网看看教程。rxjs的操作符确实博大精深，一个操作符就能实现一个功能，组合起来更加精妙。\r\n```jsx\r\nconst snake$ = of([{x:1,y:1}])\r\nconst food$ = of([{x:4,y:4}])\r\nconst isPaused$ = of(true)\r\nconst isGameOver$ = of(falsse)\r\nconst score$ = of(0)\r\n\r\nconst game$ = combineLatest([snake$, pause$, food$, score$, gameOver$]).pipe(\r\n            takeWhile(([snake, isPaused, food, score, isGameOver]) => !isGameOver, true)\r\n        )\r\n\r\nuseEffect(()=>{\r\n    const sub = game$.subscribe(game => renderGame(game))\r\n    return () => {\r\n        sub.unsubcribe();\r\n    }\r\n})\r\n```\r\n### 实现snake$\r\n\r\n1. 让蛇动起来\r\n首先我们让蛇动起来，很容易就想到interval用每隔一定时间发送一个值然后更新snake$，这里通过一个scan操作符记录上次的结果。scan和reduce很像，只是它处理的不是数组而是一个流。现在每秒发送一个值，然后snake更新x坐标加1，y坐标不变，相当于蛇向右边移动。\r\n```jsx\r\n    const snake$ = interval(1000).pipe(\r\n        scan((snake,_) => {\r\n            //现在我们假设🐍的方向是向右\r\n            let head = snake[0];\r\n            let _x,_y;\r\n            _x = head.x +1;\r\n            _y = head.y;\r\n            return [{x:_x,y:_y}]\r\n        },[{x:1,y:1}])\r\n    )\r\n```\r\n2. 控制蛇的方向\r\n现在蛇可以动了，我们要控制它的方向，通过监听键盘上下左右键，控制蛇的下一个位置.我们加入一个新的流dir\\$,并更新snake\\$。再次强调我们不解释各种操作符的用法，请看注释或者自行学习。\r\n```jsx\r\n    const KEY_EVENTS_DIR = [\r\n        \"ArrowUp\",\r\n        \"ArrowDown\",\r\n        \"ArrowLeft\",\r\n        \"ArrowRight\"\r\n    ]\r\n    const KEY_OPPOSITE = {\r\n        ArrowUp: \"ArrowDown\",\r\n        ArrowDown: \"ArrowUp\",\r\n        ArrowRight: \"ArrowLeft\",\r\n        ArrowLeft: \"ArrowRight\",\r\n    }\r\n    const dir$ = fromEvent(document, \"keydown\").pipe(\r\n        pluck(\"key\"), //从event中取出key\r\n        filter((key) => KEY_EVENTS_DIR.includes(key)), //过滤掉不是方向键的event\r\n        startWith(\"ArrowRight\"), //设置初始方向\r\n        distinctUntilChanged(),  //同一个键盘连续2次不会重复发送\r\n    );\r\n    const snake$ = interval(1000).pipe(\r\n        withLastFrom(dir$),  //每次interval都去取dir的最新值 \r\n        scan((snake,[_,dir]) => {\r\n            let head = snake[0];\r\n            let _x,_y;\r\n            switch (dir) {\r\n                case \"ArrowRight\":\r\n                    _x = _x >= size - 1 ? 0 : _x + 1;\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    _x = _x <= 0 ? size - 1 : _x - 1;\r\n                    break;\r\n                case \"ArrowUp\":\r\n                    _y = _y <= 0 ? size - 1 : _y - 1;\r\n                    break;\r\n                case \"ArrowDown\":\r\n                    _y = _y >= size - 1 ? 0 : _y + 1;\r\n                    break;\r\n            }\r\n            return [{x:_x,y:_y}]\r\n        },[{x:1,y:1}])\r\n    )\r\n```\r\n\r\n现在我们可以通过鼠标控制蛇上下左右自由的移动了。但是我希望在手机上也能玩，可以通过监听touch事件实现。所以我们再加一个手势判断的流gestureDir$。读者应该可以看出现在我们代码逻辑很清晰，一个个简单的功能组成最终的功能，各自完成自己的工作。这就是rxjs的强大之处。想一下我们现在不用rxjs，要实现一个dir\\$的功能，感觉有一大堆代码要写，而且很散乱，没有一定的功力很难写的很漂亮逻辑这么清晰。\r\n\r\n```jsx\r\n     const keyDir$ = fromEvent(document, \"keydown\").pipe(\r\n         pluck(\"key\"),\r\n         filter((key) => KEY_EVENTS_DIR.includes(key)),\r\n         startWith(\"ArrowRight\"),\r\n         distinctUntilChanged(),\r\n     );\r\n\r\n    const gestureDir$ = function () {\r\n        if ('ontouchstart' in document.documentElement) {\r\n            return fromEvent(document, \"touchstart\").pipe(\r\n                switchMap((startEvent) =>\r\n                    fromEvent(document, \"touchmove\").pipe(\r\n                        takeUntil(fromEvent(document, \"touchend\")),\r\n                        takeLast(1),\r\n                        map((event) => {\r\n                            let deltaX = event.touches[0].pageX - startEvent.touches[0].pageX;\r\n                            let deltaY = event.touches[0].pageY - startEvent.touches[0].pageY;\r\n                            if (deltaX > 0 && Math.abs(deltaX) > Math.abs(deltaY)) {\r\n                                return KEY_EVENTS_DIR[3];\r\n                            } else if (deltaX < 0 && Math.abs(deltaX) > Math.abs(deltaY)) {\r\n                                return KEY_EVENTS_DIR[2];\r\n                            } else if (deltaY > 0 && Math.abs(deltaY) > Math.abs(deltaX)) {\r\n                                return KEY_EVENTS_DIR[1];\r\n                            } else {\r\n                                return KEY_EVENTS_DIR[0]\r\n                            }\r\n                        }),\r\n                    )\r\n                )\r\n            )\r\n        }\r\n        return NEVER\r\n    }()\r\n\r\n    const dir$ = merge(keyDir$, gestureDir$);\r\n    \r\n```\r\n3. 让蛇吃苹果变长\r\n   现在蛇可以控制方向4处移动了，但是还不能变长，我们要实现在蛇吃到苹果时长度增加1并且苹果的位置改变。这里有点复杂，因为snake\\$和food\\$相互关联了起来。snake\\$需要拿到当前food\\$的值来判断是否吃到🍎而food\\$也需要拿到snake的值来生成新的位置但不要和snake的位置重叠。我们引入一个新的流eatFood\\$来通知food\\$。\r\n   ```jsx\r\n\r\n    //随机生成食物\r\n   const createFood = (size, data) => {\r\n        let x = Math.floor(Math.random() * size);\r\n        let y = Math.floor(Math.random() * size);\r\n        if (data.some(item => item.x === x && item.y === y)) {\r\n            return createFood(size, data);\r\n        }\r\n        return { x, y }\r\n    }\r\n\r\n    const eatFood$ = new BehaviorSubject([]);\r\n\r\n    const food$ = eatFood$.pipe(\r\n        map(snake => createFood(size, snake)),\r\n        shareReplay(1), //为什么要用shareReplay?\r\n    )\r\n\r\n    const snake$ = interval(1000).pipe(\r\n        withLastFrom(dir$,food$),  //每次interval都去取dir的最新值 \r\n        scan((snake,[_,dir,food]) => {\r\n            let head = snake[0];\r\n            let _x,_y;\r\n            switch (dir) {\r\n                case \"ArrowRight\":\r\n                    _x = _x >= size - 1 ? 0 : _x + 1;\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    _x = _x <= 0 ? size - 1 : _x - 1;\r\n                    break;\r\n                case \"ArrowUp\":\r\n                    _y = _y <= 0 ? size - 1 : _y - 1;\r\n                    break;\r\n                case \"ArrowDown\":\r\n                    _y = _y >= size - 1 ? 0 : _y + 1;\r\n                    break;\r\n            }\r\n            snake.unshift({ x: _x, y: _y });\r\n                //吃到🍎,通知更新food$\r\n            if (food.x === _x && food.y === _y) {\r\n                eatFood$.next(snake) //通知food$更新\r\n            } else {\r\n                snake.pop();\r\n            }\r\n            return [...snake];\r\n        },[{x:1,y:1}])\r\n    )\r\n   ```\r\n4. 增加暂停功能\r\n   现在蛇已经能自由移动，通过吃🍎不断的变长了，游戏的基本逻辑已经实现。接下来我们增加一个暂停和恢复的功能。请注意看pause实现，我们通过switchMap操作符来控制是否往下面的流发送值。\r\n    ```jsx\r\n    const pauseClick$ = fromEvent(document.getElementById(\"pauseORresume\"), \"click\");\r\n\r\n    const pauseKey$ = fromEvent(document, \"keydown\").pipe(\r\n        pluck(\"code\"),\r\n        filter((code) => code === \"Space\")\r\n    )\r\n\r\n    const pause$ = merge(pauseClick$, pauseKey$).pipe(\r\n        startWith(true),\r\n        scan((current, prev) => current ? false : true, false)\r\n    )\r\n\r\n    const interval$ = interval(200);\r\n\r\n    const snake$ = pause$.pipe(\r\n        switchMap((isPaused) => isPaused ? NEVER : inteval$),\r\n        startWith(\"init\"),\r\n        withLastFrom(dir$,food$),  //每次interval都去取dir的最新值 \r\n        scan((snake,[_,dir,food]) => {\r\n            let head = snake[0];\r\n            let _x,_y;\r\n            switch (dir) {\r\n                case \"ArrowRight\":\r\n                    _x = _x >= size - 1 ? 0 : _x + 1;\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    _x = _x <= 0 ? size - 1 : _x - 1;\r\n                    break;\r\n                case \"ArrowUp\":\r\n                    _y = _y <= 0 ? size - 1 : _y - 1;\r\n                    break;\r\n                case \"ArrowDown\":\r\n                    _y = _y >= size - 1 ? 0 : _y + 1;\r\n                    break;\r\n            }\r\n            snake.unshift({ x: _x, y: _y });\r\n                //吃到🍎,通知更新food$\r\n            if (food.x === _x && food.y === _y) {\r\n                eatFood$.next(snake) //通知food$更新\r\n            } else {\r\n                snake.pop();\r\n            }\r\n            return [...snake];\r\n        },[{x:1,y:1}])\r\n    )\r\n   ```\r\n5. 增加gameover判断\r\n现在游戏逻辑基本完成，但是什么时候游戏结束呢，我们还需要实现isGameOver\\$的逻辑，当蛇咬到自己的时候游戏结束，在snake\\$里做判断就行。\r\n```jsx\r\n    const checkGameOver = (snake) => {\r\n        let head = snake[0];\r\n        return snake.slice(1).some(item => item.x === head.x && item.y ===  head.y);\r\n    }\r\n    const snake$ = pause$.pipe(\r\n        switchMap((isPaused) => isPaused ? NEVER : inteval$),\r\n        startWith(\"init\"),\r\n        withLastFrom(dir$,food$),  //每次interval都去取dir的最新值 \r\n        scan((snake,[_,dir,food]) => {\r\n            let head = snake[0];\r\n            let _x,_y;\r\n            switch (dir) {\r\n                case \"ArrowRight\":\r\n                    _x = _x >= size - 1 ? 0 : _x + 1;\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    _x = _x <= 0 ? size - 1 : _x - 1;\r\n                    break;\r\n                case \"ArrowUp\":\r\n                    _y = _y <= 0 ? size - 1 : _y - 1;\r\n                    break;\r\n                case \"ArrowDown\":\r\n                    _y = _y >= size - 1 ? 0 : _y + 1;\r\n                    break;\r\n            }\r\n            snake.unshift({ x: _x, y: _y });\r\n                //吃到🍎,通知更新food$\r\n            if (food.x === _x && food.y === _y) {\r\n                eatFood$.next(snake) //通知food$更新\r\n            } else {\r\n                snake.pop();\r\n            }\r\n            if (checkGameOver(snake)) {\r\n                gameOver$.next(true)\r\n            }\r\n            return [...snake];\r\n        },[{x:1,y:1}])\r\n    )\r\n\r\n```\r\n6. 增加reset功能\r\n游戏结束时我们还需要重置游戏的功能。我们先把之前的逻辑整理成一个方法createGame，然后再增加一个startGame的方法，每次reset就重建一个game\\$达到reset的作用。最终代码如下：\r\n```jsx\r\n        const createGame = () => {\r\n        const gameOver$ = new BehaviorSubject(false);\r\n\r\n        const keyDir$ = fromEvent(document, \"keydown\").pipe(\r\n            pluck(\"key\"),\r\n            filter((key) => KEY_EVENTS_DIR.includes(key)),\r\n            startWith(\"ArrowRight\"),\r\n            distinctUntilChanged(),\r\n        );\r\n\r\n        const gestureDir$ = function () {\r\n            if ('ontouchstart' in document.documentElement) {\r\n                return fromEvent(document, \"touchstart\").pipe(\r\n                    switchMap((startEvent) =>\r\n                        fromEvent(document, \"touchmove\").pipe(\r\n                            takeUntil(fromEvent(document, \"touchend\")),\r\n                            takeLast(1),\r\n                            map((event) => {\r\n                                let deltaX = event.touches[0].pageX - startEvent.touches[0].pageX;\r\n                                let deltaY = event.touches[0].pageY - startEvent.touches[0].pageY;\r\n                                if (deltaX > 0 && Math.abs(deltaX) > Math.abs(deltaY)) {\r\n                                    return KEY_EVENTS_DIR[3];\r\n                                } else if (deltaX < 0 && Math.abs(deltaX) > Math.abs(deltaY)) {\r\n                                    return KEY_EVENTS_DIR[2];\r\n                                } else if (deltaY > 0 && Math.abs(deltaY) > Math.abs(deltaX)) {\r\n                                    return KEY_EVENTS_DIR[1];\r\n                                } else {\r\n                                    return KEY_EVENTS_DIR[0]\r\n                                }\r\n                            }),\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            return NEVER\r\n        }()\r\n\r\n\r\n        const dir$ = merge(keyDir$, gestureDir$);\r\n\r\n        const pauseClick$ = fromEvent(document.getElementById(\"pauseORresume\"), \"click\");\r\n        const pauseKey$ = fromEvent(document, \"keydown\").pipe(\r\n            pluck(\"code\"),\r\n            filter((code) => code === \"Space\")\r\n        )\r\n        const pause$ = merge(pauseClick$, pauseKey$).pipe(\r\n            startWith(true),\r\n            scan((current, prev) => current ? false : true, false)\r\n        )\r\n\r\n        const eatFood$ = new BehaviorSubject([]);\r\n\r\n        const score$ = eatFood$.pipe(\r\n            scan((score, _) => {\r\n                return score + 1\r\n            }, -1)\r\n        )\r\n\r\n        const food$ = eatFood$.pipe(\r\n            map(snake => createFood(size, snake)),\r\n            shareReplay(1),\r\n        )\r\n\r\n        //增加小需求每吃5个苹果速度增加\r\n        const inteval$ = score$.pipe(\r\n            filter(score => score % 5 === 0),\r\n            map(score => {\r\n                let level = Math.floor(score / 5);\r\n                level = level >= 3 ? 3 : level;\r\n                return INTERVAL_TIMES[level];\r\n            }),\r\n            distinctUntilChanged(),\r\n            switchMap((time) => interval(time)),\r\n        )\r\n\r\n        const snake$ = pause$.pipe(\r\n            switchMap((isPaused) => isPaused ? NEVER : inteval$),\r\n            startWith(\"init\"),\r\n            withLatestFrom(dir$, food$),\r\n            //快速切换相反方向导致蛇吃到自己\r\n            scan((prev, [_, dir, food]) => {\r\n                if (KEY_OPPOSITE[dir] === prev[0]) {\r\n                    return [prev[0], food]\r\n                }\r\n                return [dir, food]\r\n            }, []),\r\n            scan((snake, [dir, food]) => {\r\n                let head = snake[0];\r\n                let _x = head.x;\r\n                let _y = head.y;\r\n                switch (dir) {\r\n                    case \"ArrowRight\":\r\n                        _x = _x >= size - 1 ? 0 : _x + 1;\r\n                        break;\r\n                    case \"ArrowLeft\":\r\n                        _x = _x <= 0 ? size - 1 : _x - 1;\r\n                        break;\r\n                    case \"ArrowUp\":\r\n                        _y = _y <= 0 ? size - 1 : _y - 1;\r\n                        break;\r\n                    case \"ArrowDown\":\r\n                        _y = _y >= size - 1 ? 0 : _y + 1;\r\n                        break;\r\n                }\r\n                snake.unshift({ x: _x, y: _y });\r\n                //吃到🍎,通知更新food$\r\n                if (food.x === _x && food.y === _y) {\r\n                    eatFood$.next(snake)\r\n                } else {\r\n                    snake.pop();\r\n                }\r\n                if (checkGameOver(snake)) {\r\n                    gameOver$.next(true)\r\n                }\r\n                return [...snake];\r\n            }, [{ x: 1, y: 1 }]),\r\n        );\r\n\r\n        const game$ = combineLatest([snake$, pause$, food$, score$, gameOver$]).pipe(\r\n            takeWhile(([snake, isPaused, food, score, isGameOver]) => !isGameOver, true)\r\n        )\r\n        return game$;\r\n    }\r\n\r\n\r\n    const renderGame = ([snake, isPaused, food, score, isGameOver]) => {\r\n        setState(state => {\r\n            return {\r\n                ...state,\r\n                snake,\r\n                isPaused,\r\n                food,\r\n                score,\r\n                isGameOver\r\n            }\r\n        })\r\n    }\r\n\r\n    const startGame = () => {\r\n        const reset$ = fromEvent(document.getElementById(\"reset\"), \"click\");\r\n        const game$ = merge(of(\"startGame\"), reset$).pipe(\r\n            switchMap(x => createGame()),\r\n        )\r\n        const sub = game$.subscribe(game => renderGame(game))\r\n        return sub;\r\n    }\r\n\r\n    useEffect(() => {\r\n        let sub = startGame();\r\n\r\n        return () => {\r\n            sub.unsubscribe();\r\n        }\r\n    }, [])\r\n```\r\n\r\n# 总结\r\n\r\n通过写一个贪吃蛇游戏确实加深了我对rxjs的理解，之前我也以为我差不多懂rxjs的用法了。但是真正写的时候为了实现各种需求还是遇到了很多问题。以我写这个demo的经验来看，rxjs真的没有说的那么简单，为了实现不同功能在不同的流之间穿插很考验你对rxjs真正理解的程度。但是不得不承认rxjs真的强大，通过组合各种简单方法实现一个复杂的功能，代码思路清晰逻辑分明，容易扩展和维护。那么到底要不要用rxjs呢?我的观点是一定要比较深入理解rxjs了再用，不然你会遇到很多麻烦的。rxjs可能不像react一样简单，随便看看文档懂了jsx和生命周期就可以动手写了。\r\n\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/3","createdAt":"2021-06-10T16:15:20Z","tags":["react"],"description":"本文主要介绍使用rxjs和react实现一个经典的贪吃蛇游戏。","keywords":["rxjs","游戏","贪吃蛇"],"headType":"article"},"__N_SSG":true}