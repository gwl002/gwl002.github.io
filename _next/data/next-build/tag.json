{"pageProps":{"list":[{"id":"e098078f0874d05907b3bbdac951bda1","title":"react-native-webview加载第三方iframe","body":"### 1. 第三方iframe 遇到cross-origin问题\r\n[设置baseUrl与iframe的domain相同](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#)\r\n```(javascript)\r\nconst ChatModal = ({ uuid, token, language, isLogin, dispatch, chatModal }) => {\r\n    const { shown } = chatModal;\r\n    // const [isLoading, setIsLoading] = useState(false);\r\n\r\n    const closeModal = () => {\r\n        dispatch({\r\n            type: 'modal/closeChatModal',\r\n        });\r\n    };\r\n\r\n    const handleMessage = ({ nativeEvent }) => {\r\n        const data = nativeEvent.data;\r\n        if (data === 'close') {\r\n            closeModal();\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Modal animationType=\"fade\" transparent={false} visible={shown}>\r\n            <SafeAreaView style={styles.container}>\r\n                <WebView\r\n                    source={{ html: html, baseUrl: 'https://chat.sleekflow.io/' }}\r\n                    style={styles.webview}\r\n                    onMessage={handleMessage}\r\n                />\r\n            </SafeAreaView>\r\n        </Modal>\r\n    );\r\n};\r\n```\r\n### 2.  通过postMessage 向rn发送event\r\n```(javascript)\r\nrootWindow.ReactNativeWebView.postMessage('close'); \r\n```\r\n\r\n### 3. [react-native中调试js](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Debugging.md#:~:text=Open%20Safari%20Preferences%20%2D%3E%20%22Advanced,you%20would%20on%20the%20web)\r\n### 3.1 ios中调试js\r\n\r\n1. Open Safari Preferences -> \"Advanced\" tab -> enable checkbox \"Show Develop menu in menu bar\"\r\n2. Start app with React Native WebView in iOS simulator or iOS device\r\n3. Safari -> Develop -> [device name] -> [app name] -> [url - title]\r\n4. You can now debug the WebView contents just as you would on the web\r\n\r\n### 3.2 android中调试js\r\n\r\n1. You will need to make the following change to MainApplication.java to enabled web contents debugging: \r\n```java\r\nimport android.webkit.WebView;\r\n\r\n  @Override\r\n  public void onCreate() {\r\n    super.onCreate();\r\n\t  ...\r\n    WebView.setWebContentsDebuggingEnabled(true);\r\n  }\r\n```\r\n2. Start app with React Native WebView in Android emulator or Android device\r\n3. Open chrome://inspect/#devices on Chrome\r\n4. Select your device on the left and select \"Inspect\" on the WebView contents you'd like to inspect\r\n5. You can now debug the WebView contents just as you would on the web\r\n\r\n### 4. html source code\r\n```(html)\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n    <head>\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">\r\n        <style>\r\n            html,body{\r\n                margin:0;\r\n                padding:0\r\n            }\r\n            #loading-overlay{\r\n                position:absolute;\r\n                width:100%;\r\n                height:100vh;\r\n                display: flex;\r\n                align-items: center;\r\n                justify-content: center;\r\n                z-index:2147483647;\r\n                background-color:white;\r\n            }\r\n            .lds-spinner {\r\n            color: official;\r\n            display: inline-block;\r\n            position: relative;\r\n            width: 80px;\r\n            height: 80px;\r\n            transform:scale(0.8)\r\n            }\r\n            .lds-spinner div {\r\n            transform-origin: 40px 40px;\r\n            animation: lds-spinner 1.2s linear infinite;\r\n            }\r\n            .lds-spinner div:after {\r\n            content: \" \";\r\n            display: block;\r\n            position: absolute;\r\n            top: 3px;\r\n            left: 37px;\r\n            width: 6px;\r\n            height: 18px;\r\n            border-radius: 20%;\r\n            background: blue;\r\n            }\r\n            .lds-spinner div:nth-child(1) {\r\n            transform: rotate(0deg);\r\n            animation-delay: -1.1s;\r\n            }\r\n            .lds-spinner div:nth-child(2) {\r\n            transform: rotate(30deg);\r\n            animation-delay: -1s;\r\n            }\r\n            .lds-spinner div:nth-child(3) {\r\n            transform: rotate(60deg);\r\n            animation-delay: -0.9s;\r\n            }\r\n            .lds-spinner div:nth-child(4) {\r\n            transform: rotate(90deg);\r\n            animation-delay: -0.8s;\r\n            }\r\n            .lds-spinner div:nth-child(5) {\r\n            transform: rotate(120deg);\r\n            animation-delay: -0.7s;\r\n            }\r\n            .lds-spinner div:nth-child(6) {\r\n            transform: rotate(150deg);\r\n            animation-delay: -0.6s;\r\n            }\r\n            .lds-spinner div:nth-child(7) {\r\n            transform: rotate(180deg);\r\n            animation-delay: -0.5s;\r\n            }\r\n            .lds-spinner div:nth-child(8) {\r\n            transform: rotate(210deg);\r\n            animation-delay: -0.4s;\r\n            }\r\n            .lds-spinner div:nth-child(9) {\r\n            transform: rotate(240deg);\r\n            animation-delay: -0.3s;\r\n            }\r\n            .lds-spinner div:nth-child(10) {\r\n            transform: rotate(270deg);\r\n            animation-delay: -0.2s;\r\n            }\r\n            .lds-spinner div:nth-child(11) {\r\n            transform: rotate(300deg);\r\n            animation-delay: -0.1s;\r\n            }\r\n            .lds-spinner div:nth-child(12) {\r\n            transform: rotate(330deg);\r\n            animation-delay: 0s;\r\n            }\r\n            @keyframes lds-spinner {\r\n            0% {\r\n                opacity: 1;\r\n            }\r\n            100% {\r\n                opacity: 0;\r\n            }\r\n            }\r\n        </style>\r\n    </head>\r\n    <body>\r\n        <div id=\"loading-overlay\">\r\n            <div class=\"lds-spinner\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div>\r\n        </div>\r\n    </body>\r\n    <script \r\n        src=\"https://chat.sleekflow.io/embed_iframe.js\" \r\n        data-id=\"travischatwidget\"\r\n        data-companyid=\"e1922105-8004-4724-97c7-859b7ff5dedf\"\r\n        type=\"text/javascript\"\r\n    >\r\n    </script>\r\n    <script>\r\n        const rootWindow = window;\r\n        const loadingEle = document.querySelector('#loading-overlay') //loading\r\n\r\n        function start(){\r\n            function checkLoad(iframe){\r\n                const iframeWindow = iframe.contentWindow.window;\r\n                const rootIframeEle = iframeWindow.document.getElementById(\"travischatroot\");\r\n                const floatButton = rootIframeEle.querySelector(\"div>button\")\r\n                if(floatButton){\r\n                    floatButton.click();\r\n                    setTimeout(() => {\r\n                        loadingEle.remove();\r\n                        const closeButton = rootIframeEle.querySelector(\"#scrollConatiner>div>button\")\r\n                        if(closeButton){\r\n                            closeButton.onclick = function(e){\r\n                                e.stopPropagation()\r\n                                rootWindow.ReactNativeWebView.postMessage('close'); \r\n                            }\r\n                        }\r\n                    }, 500);\r\n                }else{\r\n                    setTimeout(function(){\r\n                        checkLoad(iframe);\r\n                    },500)\r\n                }\r\n            }\r\n\r\n            const iframeEle = document.querySelector('iframe#travischatwidget')\r\n            if(iframeEle){\r\n                iframeEle.addEventListener('load',function(){\r\n                    checkLoad(iframeEle)\r\n                })\r\n            }else{\r\n                setTimeout(function(){\r\n                    start()\r\n                },500)\r\n            }\r\n        }\r\n        \r\n        window.onload = function(){\r\n            start();\r\n        }\r\n    </script> \r\n</html>\r\n```\r\n\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/14","createdAt":"2022-04-11T14:40:39Z","tags":[{"name":"javascript","color":"1d76db"},{"name":"react-native","color":"5319e7"}]},{"id":"844206ed01e814fc9438e7b4e9add988","title":"react-native-camera拍照图片自动旋转","body":"[Android: captured image is always rotated](https://github.com/react-native-camera/react-native-camera/issues/1807)\r\n[taking photos in landscape mode is rotating the photo 90º (turning to portrait)](https://github.com/react-native-camera/react-native-camera/issues/1570)","url":"https://github.com/gwl002/gwl002.github.io/issues/13","createdAt":"2022-03-28T03:43:27Z","tags":[]},{"id":"c8f8e9c93e4779383ed990a92b6c0831","title":"理解animation-fill-mode属性","body":"animation-fill-mode作为css3动画的一个重要属性很常见，但是大多用于把动画停在最后一帧，也就是**forwards**值的用法。在多年的前端开发中很少关注其他几个值，今天看[文档](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode)发现对于backwards(一直以为就是回到初始状态和none没什么两样)和both一直没有正确的了解，文档英文描述晦涩难懂，demo也没有什么详细说明，所以打算一探究竟。\r\n\r\n### 属性值\r\n- none 默认值\r\n> The animation will not apply any styles to the target when it's not executing. The element will instead be displayed using any other CSS rules applied to it. This is the default value.\r\n\r\n    在动画不执行时，不会赋予任何target任何style，动画执行结束回归原样\r\n- forwards\r\n> The target will retain the computed values set by the last keyframe encountered during execution.\r\n\r\n    target在动画执行结束后保持最后一帧的style\r\n- backwards\r\n\r\n> The animation will apply the values defined in the first relevant keyframe as soon as it is applied to the target, and retain this during the animation-delay period.\r\n\r\n    动画将在执行的第一时间将style赋予target，包括delay的时候，这就是none和backwards的区别，当第一帧的属性和target原来的属性不同的时候特别明显。\r\n- both\r\n\r\n> The animation will follow the rules for both forwards and backwards, thus extending the animation properties in both directions.\r\n    动画将同时有forwards和afterwards的特性。\r\n\r\n### [demo](https://jsfiddle.net/gwl002/57drgsct/23/)\r\n比较4个值不同的表现\r\n- none 小球先是绿色，delay3秒后才变为红色，最后变黄色，回到原点\r\n- forwards 小球先是绿色，delay3秒后才变为红色，最后变黄色，保持在终点\r\n- afterwards 小球直接变红色，delay3秒后，动画开始，慢慢变黄色，动画结束回到原点\r\n- both 小球直接变红色，delay3秒后，动画开始，慢慢变黄色，动画结束保持在终点\r\n\r\n### 总结\r\n以前想当然的以为afterwards就是回到原点，forwards就是保持在终点，其实是错误的。afterwards是在动画开始时第一时间选择第一帧的style，有delay就是delay开始时。\r\n\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/12","createdAt":"2021-12-21T14:49:31Z","tags":[{"name":"css","color":"F49416"}],"description":"理解css动画属性animation-fill-mode为both的情况","keywords":["css","animation","animation-fill-mode"]},{"id":"0bbbbb167d67a80165c6ffc3a65d61c4","title":"\"Android build error  AAPT: error: resource android:attr/lStar not found\"","body":"### 问题\r\nExecution failed for task ':app:processDebugResources'.\r\n> A failure occurred while executing com.android.build.gradle.internal.tasks.Workers$ActionFacade\r\n   > Android resource linking failed\r\n     /Users/devingong/.gradle/caches/transforms-2/files-2.1/f616efa5326a198920e8ac1c64cb6655/core-1.8.0-alpha02/res/values/values.xml:105:5-114:25: AAPT: error: resource android:attr/lStar not found.\r\n\r\n### 解决办法\r\n添加androidXCore = \"1.6.0\"\r\n```groovy\r\nbuildscript {\r\n    ext {\r\n        buildToolsVersion = \"28.0.3\"\r\n        minSdkVersion = 21\r\n        compileSdkVersion = 29\r\n        targetSdkVersion = 28\r\n        adroidXCore = \"1.6.0\"\r\n    }\r\n    repositories {\r\n        google()\r\n        jcenter()\r\n    }\r\n    dependencies {\r\n        classpath(\"com.android.tools.build:gradle:3.5.3\")\r\n        // NOTE: Do not place your application dependencies here; they belong\r\n        // in the individual module build.gradle files\r\n    }\r\n}\r\n```\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/11","createdAt":"2021-12-20T03:01:03Z","tags":[{"name":"工作经验","color":"bfdadc"},{"name":"react-native","color":"5319e7"}]},{"id":"a4ed040911fb1de4110cbb53cb12df7b","title":"No signature found in package of version 2","body":"### 最近googleplay要求将android target version升级至30，不然不能上store。升级后又发现在android11上install失败。查找原因发现，在安卓11的机器上adb install后出现这个错误，search后发现原来android11以后不再支持v1签名，必须使用v2签名。\r\n![image](https://user-images.githubusercontent.com/18588945/142794410-c6ff32ab-157d-4db6-ad2b-283ebfab6f2b.png)\r\n\r\n### v1签名和v2签名的区别\r\n```\r\nV1：可对签名后的文件，作适当修改，并重新压缩。 \r\nV2：不能对签名后的 APK作任何修改，包括重新解压。因为它是针对字节进行的签名，所以任何改动都会影响最终结果。\r\n```\r\n\r\n### 解决方案\r\n1. 手动\r\n```\r\nsigningConfigs {\r\n        debug {\r\n            storeFile file('xxxxx.jks')\r\n            storePassword '123456'\r\n            keyAlias 'dev'\r\n            keyPassword '123456'\r\n            v2SigningEnabled true\r\n        }\r\n    }\r\n```\r\n2. appcenter\r\n删掉keystore文件，重新上传就自动好了\r\n[https://github.com/microsoft/appcenter/issues/1990#issuecomment-856960698](url)\r\n\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/10","createdAt":"2021-11-22T03:10:39Z","tags":[{"name":"工作经验","color":"bfdadc"},{"name":"react-native","color":"5319e7"}]},{"id":"7bbc5d66b3b4be1d1738caac348a4ee7","title":"react-native 0.62在xcode13遇到build error解决","body":"最近为了将app项目发布到ios15版本，升级了xcode到13，遇到几个bug，这里记录解决方案。\r\n\r\n### 1. No matching function for call to 'RCTBridgeModuleNameForClass'\r\n```\r\n# 在 ios/Podfile 中加入一下代码\r\ndef find_and_replace(dir, findstr, replacestr)\r\n    Dir[dir].each do |name|\r\n        text = File.read(name)\r\n        replace = text.gsub(findstr,replacestr)\r\n        if text != replace\r\n            puts \"Fix: \" + name\r\n            File.open(name, \"w\") { |file| file.puts replace }\r\n            STDOUT.flush\r\n        end\r\n    end\r\n    Dir[dir + '*/'].each(&method(:find_and_replace))\r\n  end\r\npost_install do |installer|\r\n  ## 以下 Fix for XCode 12.5\r\n    find_and_replace(\r\n    \"../node_modules/react-native/React/CxxBridge/RCTCxxBridge.mm\",\r\n    \"_initializeModules:(NSArray<id<RCTBridgeModule>> *)modules\", \r\n    \"_initializeModules:(NSArray<Class> *)modules\")\r\n    \r\n    find_and_replace(\r\n    \"../node_modules/react-native/ReactCommon/turbomodule/core/platform/ios/RCTTurboModuleManager.mm\",\r\n    \"RCTBridgeModuleNameForClass(strongModule))\", \r\n    \"RCTBridgeModuleNameForClass(Class(strongModule)))\"\r\n    )\r\n    installer.pods_project.targets.each do |target|\r\n      target.build_configurations.each do |config|\r\n        config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '9.0'\r\n      end\r\n    end\r\n  end\r\n```\r\n### 2. undefined symbol: __swift_force_load_$_swiftfileprovider\r\n[rn官方最新解决方案](https://github.com/facebook/react-native/commit/eb938863063f5535735af2be4e706f70647e5b90)\r\n\r\n### 3. 删除flipper相关代码\r\n\r\n[相关链接](https://github.com/facebook/react-native/issues/31480)","url":"https://github.com/gwl002/gwl002.github.io/issues/9","createdAt":"2021-09-08T06:04:12Z","tags":[]},{"id":"0a541890680756b16f51cf1680e2c53d","title":"webpack分包学习笔记","body":"### 1. optimization.runtimeChunk\r\n设置runtimeChunk是将包含chunks 映射关系的 list单独从 app.js里提取出来，因为每一个 chunk 的 id 基本都是基于内容 hash 出来的，所以每次改动都会影响它，如果不将它提取出来的话，等于app.js每次都会改变。缓存就失效了。设置runtimeChunk之后，webpack就会生成一个个runtime~xxx.js的文件。\r\n```jsx\r\nmodule.exports = {\r\n  //...\r\n  optimization: {\r\n    runtimeChunk: {\r\n      name: (entrypoint) => `runtime~${entrypoint.name}`,\r\n    },\r\n    // boolean\r\n    // string single | multiple\r\n    // object name:()=>null\r\n};\r\n```\r\n### 2. optimization.moduleIds 和 optimization.chunkIds\r\n[webpack稳定moduleid和chunkid以实现持久化缓存的梳理](https://blog.csdn.net/weixin_33727510/article/details/91362710)\r\n\r\n### 3. optimization.splitChunks\r\n[理解webpack4.splitChunks](https://www.cnblogs.com/kwzm/p/10314438.html)","url":"https://github.com/gwl002/gwl002.github.io/issues/8","createdAt":"2021-06-25T14:55:49Z","tags":[]},{"id":"46711a24cc4d8cb347b59e2d9be84884","title":"script标签上async 和 defer的区别","body":"经常看到一些cdn的script标签上有async和defer，知道大概是异步加载却一直没深究到底有什么用，今天看到一片博文，大概了解了这两者的作用和区别。\r\n\r\n# JS 加载阻塞\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\"/>\r\n    <script src=\"https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js\"></script>\r\n</head>\r\n<body>\r\n    <h1>我是 h1 标签</h1>\r\n</body>\r\n</html>\r\n```\r\n将浏览器网速调到50k/s会发现，刷新浏览器，观察 Elements 面，一直未加载出 h1 标签（期间页面一直白屏），直到 JS 加载完成后，DOM 中才出现，这足以说明了 JS 会阻塞定义在其之后的 DOM 的加载。\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\"/>\r\n    <script async src=\"https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js\"></script>\r\n</head>\r\n<body>\r\n    <h1>我是 h1 标签</h1>\r\n</body>\r\n</html>\r\n```\r\n在script上加上async(异步)或者defer(延迟)会发现都不会阻塞DOM的加载。那么二者有什么区别呢？分析浏览遇到script的流程：\r\n1. 暂停解析 DOM；\r\n2. 执行 script 里的脚本，如果该 script 是外链，则会先下载它，下载完成后立刻执行；\r\n3. 执行完成后继续解析剩余 DOM。\r\n\r\n但是defer和async有所不同。\r\n\r\n# defer的特点\r\n- 对于 defer 的 script，浏览器会继续解析 html，且同时并行下载脚本，等 DOM 构建完成后，才会开始执行脚本，所以它不会造成阻塞；\r\n- defer 脚本下载完成后，执行时间一定是 DOMContentLoaded 事件触发之前执行；\r\n- **多个 defer 的脚本执行顺序严格按照定义顺序进行，而不是先下载好的先执行；**\r\n\r\n# async 特点\r\n- 对于 async 的 script，浏览器会继续解析 html，且同时并行下载脚本，一旦脚本下载完成会立刻执行；和 defer 一样，它在下载的时候也不会造成阻塞，但是如果它下载完成后 DOM 还没解析完成，则执行脚本的时候是会阻塞解析的；\r\n- async 脚本的执行 和 DOMContentLoaded 的触发顺序无法明确谁先谁后，因为脚本可能在 DOM 构建完成时还没下载完，也可能早就下载好了；\r\n- 多个 async，按照谁先下载完成谁先执行的原则进行，所以当它们之间有顺序依赖的时候特别容易出错。\r\n\r\n> defer 和 async 都只能用于外部脚本，如果 script 没有 src 属性，则会忽略它们。\r\n\r\n# 总结\r\n根据defer和async的不同特点可以得出一些结论，在一些需要相互依赖的脚本，按顺序执行的脚本需要使用defer；而没有依赖关系谁先下载完谁先执行就好的情况下可以用async。\r\n\r\n# 参考文献\r\n1. [探究网页资源究竟是如何阻塞浏览器加载的](https://bubuzou.com/2020/12/26/browser-block/)\r\n2. [浅谈script标签中的async和defer](https://www.cnblogs.com/jiasm/p/7683930.html)\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/7","createdAt":"2021-06-25T14:48:06Z","tags":[{"name":"javascript","color":"1d76db"}]},{"id":"4c3e4ca0899dd22eeb674d05e4811887","title":"react-native下载pdf文件","body":"很久就实现过的功能，今天又遇到了，竟然无从下手，只好去翻翻旧代码并在这里记录一下也方便日后查看。\r\n\r\n# 需求分析\r\n- ajax请求pdf文件\r\n- 转成base64\r\n- 下载到手机，需要能从外部App打开\r\n\r\n### 1. 首先获取pdf文件二进制\r\n```jsx\r\nasync function getPdfBinary(url) {\r\n    return new Promise((resolve, reject) => {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open(\"GET\", url, true);\r\n        xhr.responseType = \"arraybuffer\"; // get the binary \r\n        xhr.setRequestHeader('content-type', 'application/json');\r\n        xhr.onload = function (event) {\r\n            var arrayBuffer = xhr.response;\r\n            var byteArray = new Uint8Array(arrayBuffer);\r\n            var len = byteArray.byteLength;\r\n            var binary = \"\"\r\n            for (var i = 0; i < len; i++) {\r\n                binary += String.fromCharCode(byteArray[i]);\r\n            }\r\n            resolve(binary);\r\n        }\r\n        xhr.send();\r\n    })\r\n}\r\n\r\n```\r\n### 2. 转成base64字符串\r\n```jsx\r\n//react-native 并没有btoa和atob方法 需要自己实现\r\nfunction base64_encode(str) {\r\n    var c1, c2, c3;\r\n    var base64EncodeChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n    var i = 0,\r\n        len = str.length,\r\n        string = '';\r\n\r\n    while (i < len) {\r\n        c1 = str.charCodeAt(i++) & 0xff;\r\n        if (i == len) {\r\n            string += base64EncodeChars.charAt(c1 >> 2);\r\n            string += base64EncodeChars.charAt((c1 & 0x3) << 4);\r\n            string += \"==\";\r\n            break;\r\n        }\r\n        c2 = str.charCodeAt(i++);\r\n        if (i == len) {\r\n            string += base64EncodeChars.charAt(c1 >> 2);\r\n            string += base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));\r\n            string += base64EncodeChars.charAt((c2 & 0xF) << 2);\r\n            string += \"=\";\r\n            break;\r\n        }\r\n        c3 = str.charCodeAt(i++);\r\n        string += base64EncodeChars.charAt(c1 >> 2);\r\n        string += base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));\r\n        string += base64EncodeChars.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6));\r\n        string += base64EncodeChars.charAt(c3 & 0x3F)\r\n    }\r\n    return string\r\n}\r\n```\r\n### 3. 下载到android手机\r\n今天刚好在stackoverflow上回答别人的问题，他需要的是expo，所以写了个expo版本的。[Base64 String to pdf JavaScript React Native then download](https://stackoverflow.com/questions/68076316/base64-string-to-pdf-javascript-react-native-then-download/68076982#68076982)\r\nFor expo\r\n```jsx\r\nconst downloadForAos = async (pdfBase64Str) => {\r\n    const folder = FileSystem.StorageAccessFramework.getUriForDirectoryInRoot(\"test\");\r\n    const permissions = await FileSystem.StorageAccessFramework.requestDirectoryPermissionsAsync(folder);\r\n    if (!permissions.granted) return;\r\n\r\n    let filePath = await FileSystem.StorageAccessFramework.createFileAsync(permissions.directoryUri, \"test.pdf\", \"application/pdf\");\r\n    // let filePath = \"content://com.android.externalstorage.documents/tree/primary%3Atest/document/primary%3Atest%2Ftest.txt\";\r\n    console.log(pdfBase64Str, \"====\");\r\n    try {\r\n        await FileSystem.StorageAccessFramework.writeAsStringAsync(filePath, pdfBase64Str, { encoding: FileSystem.EncodingType.Base64 });\r\n        alert(\"download success!\")\r\n    } catch (err) {\r\n        console.log(err);\r\n    }\r\n}\r\n```\r\nFor android\r\n``` jsx\r\nconst downloadForAos = async (pdfBase64Str) => {\r\n    const fileName = `/${Date.now()}_report.pdf`;\r\n    const path = RNFS.DownloadDirectoryPath + fileName;\r\n    try {\r\n        const granted = await PermissionsAndroid.request(\r\n            PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE,\r\n        );\r\n        if (granted) {\r\n            RNFS.writeFile(path, pdfBase64Str, \"base64\").then(res => {\r\n                ToastAndroid.show(I18n.t(\"myHealth.Downloaded\"), ToastAndroid.SHORT);\r\n            }).catch(error => {\r\n                ToastAndroid.show(I18n.t(\"myHealth.DownloadFailed\"), ToastAndroid.SHORT);\r\n            })\r\n        }\r\n    } catch (err) {\r\n        console.warn(err);\r\n    }\r\n}\r\n```\r\n### 4. 下载到ios手机\r\nios不能直接下载文件到外部app，只能通过分享到file app实现。找了很久没找到其他办法，有其他办法的大神请多多指教。\r\n```jsx\r\nconst downloadPdfForIos = async (pdf) => {\r\n    const url = \"data:application/pdf;base64,\" + pdf;\r\n    const shareOptions = {\r\n        title: 'image report',\r\n        failOnCancel: false,\r\n        saveToFiles: true,\r\n        url: url, // base64 with mimeType or path to local file\r\n    };\r\n    try {\r\n        const ShareResponse = await Share.open(shareOptions);\r\n        Alert.alert(\r\n            null,\r\n            I18n.t(\"myHealth.Downloaded\"),\r\n            [\r\n                {\r\n                    text: I18n.t(\"common.OK\"),\r\n                    onPress: () => null\r\n                }\r\n            ]\r\n        );\r\n    } catch (error) {\r\n        if (error.error && error.error.code === \"ECANCELLED500\") {\r\n            console.warn(\"canceled\");\r\n        } else {\r\n            Alert.alert(\r\n                null,\r\n                I18n.t(\"myHealth.DownloadFailed\"),\r\n                [\r\n                    {\r\n                        text: I18n.t(\"common.OK\"),\r\n                        onPress: () => null\r\n                    }\r\n                ]\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/6","createdAt":"2021-06-22T12:55:44Z","tags":[{"name":"react-native","color":"5319e7"}]},{"id":"ad487137feaed0cb496babdfc158080d","title":"使用imagemagic制作瓦片地图","body":"之前有个项目客户给一张精度很高的图让做成那种能够缩放的地图的效果。一开始的想法是直接加载大图，然后通过手势去控制图片的scale来实现，后来觉得不妥，高精度图片的体积实在太大，加载时间太长，效果很不好。通过研究发现[openlayers](https://openlayers.org/)这种专门用来加载地图的库才是更好的选择。但是怎么把图片制作成那种瓦片地图是个问题。\r\n\r\n>瓦片地图金字塔模型是一种多分辨率层次模型，从瓦片金字塔的底层到顶层，分辨率越来越低，但表示的地理范围不变。首先确定地图服务平台所要提供的缩放级别的数量N，把缩放级别最高、地图比例尺最大的地图图片作为金字塔的底层，即第0层，并对其进行分块，从地图图片的左上角开始，从左至右、从上到下进行切割，分割成相同大小(比如256x256像素)的正方形地图瓦片，形成第0层瓦片矩阵;在第0层地图图片的基础上，按每像素分割为2×2个像素的方法生成第1层地图图片，并对其进行分块，分割成与下一层相同大小的正方形地图瓦片，形成第1层瓦片矩阵;采用同样的方法生成第2层瓦片矩阵;…;如此下去，直到第N一1层，构成整个瓦片金字塔。\r\n\r\n# 原理\r\n瓦片地图的原理很简单。假设客户给的原图为（512*4，512*4），这是我们地图能够达到的最高分辨率，但是假设我们的视窗只有512*512，此时我们只能看到左上角1/16的部分。假设用户最开始看到的图包含整个地图，也就是512*512，此时地图被缩放了16倍，宽高个4倍，此时设level为1，那么当放大一倍时，此时地图实际图片大小为（512*2，512*2），此时level为2，当再放大一倍时，此时level为3，刚好为原图，分辨率最高。那么我们只要想办法把原图按不同level缩放切割就行。level1就是直接宽高各缩放4倍，level2各缩放2倍，再把它切成4张，每张大小为512*512，level3的时候不用缩放，直接切成16张，同样每张512*512.我们把\r\n不同level的图片放在不同的文件夹下，然后用能够加载瓦片地图的库就能加载，例如openlayers。所以我们剩下的问题就是怎么切图了。\r\n```javascript\r\nimport 'ol/ol.css';\r\nimport Map from 'ol/Map';\r\nimport TileLayer from 'ol/layer/Tile';\r\nimport View from 'ol/View';\r\nimport XYZ from 'ol/source/XYZ';\r\n\r\nvar map = new Map({\r\n  target: 'map',\r\n  layers: [\r\n    new TileLayer({\r\n      source: new XYZ({\r\n        url:\r\n          'https://localhost:9080/tiles/{z}-{x}-{y}.png'    //因为我的图片是 1-1-1这种形式组成所以这里是这样，如果你的图片是按等级放在不同文件夹要写成 https://localhost:9080/tiles/{z}/{x}/{y}.png 具体怎么放要看你如何组织的tiles结构\r\n      }),\r\n    }) ],\r\n  view: new View({\r\n    center: [-472202, 7530279],\r\n    zoom: 12,\r\n  }),\r\n});\r\n```\r\n\r\n<img width=\"967\" alt=\"QQ20210615-225842@2x\" src=\"https://user-images.githubusercontent.com/18588945/122076316-5af83c00-ce2d-11eb-9f5e-b144e416ee1f.png\">\r\n\r\n# 使用imagemagic处理图片\r\n> Use ImageMagick® to create, edit, compose, or convert digital images. It can read and write images in a variety of formats (over 200) including PNG, JPEG, GIF, WebP, HEIC, SVG, PDF, DPX, EXR and TIFF. ImageMagick can resize, flip, mirror, rotate, distort, shear and transform images, adjust image colors, apply various special effects, or draw text, lines, polygons, ellipses and Bézier curves.\r\n\r\n[imagemagic](https://imagemagick.org/index.php)是一个强大的图片处理工具，可以用命令行直接处理图片，可以很方便的实现各种图片处理操作。虽然很强大但不得不说文档很晦涩难懂，我也只是为了完成这个任务熟悉了几个命令而已，完全谈不上精通。\r\n[我们的切图工具分2个步骤，第一步就是按不同level切图，但是因为并不是刚好如原理分析里讲的那么刚好就是整数倍，地图原图往往不是刚好是正方形，比如切的瓦片每个为512*512，切到边上的时候可能只有360*400这样的，这时需要把它补成512*512，不然会有奇怪的现象发生。注意，脚本里有些参数要根据你的实际情况自己设置。[源码地址](https://github.com/gwl002/imagemagicScript)\r\n```bash\r\n#! /bin/bash\r\n#cropFile.sh\r\nINDEX=1\r\nIMAGE_WIDTH=10752   #原图宽度\r\nIMAGE_HEIGHT=21504  #原图高度\r\n\r\nfor file in `ls \"originImages\"`;do #将原图放在orginalImages文件夹下\r\n\techo \"processing ${file}\"\r\n\tfile_base=$(basename $file .png) #拿到原图名称\r\n\ttiles_dir=\"${file_base}_tiles\"   #碰到有无目标文件夹，有则直接下一步，没有就建立文件夹\r\n\tif [ -e \"${tiles_dir}\" ] && [ -d \"${tiles_dir}\" ];then \r\n\t\techo \"${tiles_dir} exisit\"\r\n\telse\r\n\t\techo \"mkdir ${tiles_dir}\"\r\n\t\tmkdir \"${tiles_dir}\"\r\n\t\techo \"mkdir ${tiles_dir} completed\"\r\n\tfi\r\n\tfor (( i=1; i<=7; i++));do    #根据你自己的需求调节所需的等级\r\n\t\techo \"processing ${file} scale ${i}\"\r\n\t\t((level= 7 - i))\r\n\t\t((scale= 2 ** (i-1)))\r\n\t\t((width= $IMAGE_WIDTH / $scale))\r\n\t\t((height= $IMAGE_HEIGHT / $scale))\r\n\t\tresizeFormat=\"${width}x${height}\"\r\n\t\techo $resizeFormat\r\n\t\tconvert \"originImages/${file}\" -resize $resizeFormat -crop 512x512 -set filename:tile ./${tiles_dir}/${level}-%[fx:page.x/512]-%[fx:page.y/512] %[filename:tile].png\r\n\t\techo \"complete ${file} scale ${i}\"\r\n\tdone\r\n\techo \"complete ${file}\"\r\n\tlet INDEX=${INDEX}+1\r\ndone\r\n```\r\n```bash\r\n#! /bin/bash\r\n#fillSize.sh\r\nSTART=`date +%s%N`;\r\nfor folder in `ls | grep \"H*tiles\"`;do  #找到所有之前切片生成的文件夹，遍历其中找到其中尺寸不对的，将其放置在512*512透明图的左上角\r\n\techo $folder\r\n\tfor image in `ls $folder`;do\r\n\t\techo $image\r\n\t\tratio=`identify \"${folder}/${image}\" | cut -d \" \" -f 3`\r\n\t\tif [ \"$ratio\" != \"128x128\" ];then\r\n\t\t\techo $ratio\r\n\t\t\tconvert \"${folder}/${image}\" -background transparent -gravity NorthWest -extent 512x512 \"${folder}/${image}\"\r\n\t\tfi \r\n\tdone\r\ndone\r\nEND=`date +%s%N`;\r\ntime=$((END-START))\r\ntime=`expr $time / 1000000`\r\necho \"totally spend time ${time}\"\r\n```\r\n\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/5","createdAt":"2021-06-15T15:45:09Z","tags":[{"name":"工作经验","color":"bfdadc"}]},{"id":"376b7ba8c34b49441c91df07b6bbbb56","title":"next-blog","body":"测试写一个next-blog","url":"https://github.com/gwl002/gwl002.github.io/issues/4","createdAt":"2021-06-11T02:42:50Z","tags":[{"name":"react","color":"8E26BB"}],"description":"some desc","keywords":[1,2,3]},{"id":"a545cc6f56f33512f79047fdad298b65","title":"rxjs实现贪吃蛇小游戏","body":"初识rxjs感觉惊奇，感觉很多复杂的逻辑好像用rxjs来写变得简单明了。断断续续得学习了一阵子，感觉很好，却一直没有真正在项目中使用过。学习而不使用过不了多久就会忘记，所以这次写一个小demo来加深一下印象。那么写什么好呢，想到以前用react写过贪吃蛇小游戏，据说rxjs很适合用来开发游戏类程序，所以决定用rxjs来写一个经典的贪吃蛇小游戏。\r\n\r\n本文并不介绍rxjs原理和各种操作符的使用，主要解释一下实现的逻辑。\r\n[源码](https://github.com/gwl002/rxjsSnakeGame)\r\n[demo展示](https://gwl002.github.io/game/greedySnake)\r\n推荐几个我经常学习的网站：\r\n\r\n- [30 天精通 RxJS (00)： 關於本系列文章](https://ithelp.ithome.com.tw/articles/10186103) 台湾同胞早年写的教程，写的很好，从原理到使用都讲的很好，还有一些生动的例子，虽然版本和写法已经有些不同，但并不影响学习。\r\n- [官网](https://rxjs.dev/)\r\n- [Learn Rxjs](https://www.learnrxjs.io/)很好的学习网站，每个操作符的解释和例子，以及各种demo。\r\n\r\n# 实现UI\r\n首先看一下整体的界面，包括Board(蛇移动的范围)、Snake(红色）、Food(绿色)、Score(分数)、暂停和重置按钮。这里我们使用react来渲染视图，当然也可以用canvas，我们只注重于逻辑，不关心ui。我们采取数据驱动视图的思维开发，逻辑和页面元素是解耦合，这种思维可以让我们很轻松从react渲染切换到canvas渲染。\r\n\r\n![image](https://user-images.githubusercontent.com/18588945/122550390-291dea00-d066-11eb-8077-2a827aeccc11.png)\r\n\r\n### Board \r\n这个结构是基本不变的，只渲染一次就够了，当然把gameover移除更好，懂react的应该理解为什么用memo。\r\n```jsx\r\n\r\nconst GameOver = ({ isGameOver }) => {\r\n    if (!isGameOver) return null;\r\n    return (\r\n        <h1 className=\"center\">GAME OVER</h1>\r\n    )\r\n}\r\n\r\nconst Board = memo(({ winWidth, size, isGameOver }) => {\r\n    const itemWidth = winWidth / size;\r\n\r\n    const Row = ({ rowIndex }) => {\r\n        return (\r\n            <div className=\"rowContainer\">\r\n                {\r\n                    Array(size).fill().map((item, index) => (\r\n                        <span key={index} className=\"boardItem\" style={{ width: itemWidth, height: itemWidth }}>\r\n                            <span></span>\r\n                        </span>\r\n                    ))\r\n                }\r\n            </div>\r\n        )\r\n    }\r\n\r\n    return (\r\n        <div id=\"board\">\r\n            {\r\n                Array(size).fill().map((item, index) => <Row key={index} />)\r\n            }\r\n            <GameOver isGameOver={isGameOver} />\r\n        </div>\r\n    )\r\n})\r\n```\r\n### Snake 和 Food\r\n```jsx\r\nconst Food = ({ food, itemWidth }) => {\r\n    if (!food) return null;\r\n\r\n    return (\r\n        <span\r\n            className=\"boardItem\"\r\n            style={{\r\n                position: \"absolute\",\r\n                width: itemWidth,\r\n                height: itemWidth,\r\n                left: itemWidth * food.x,\r\n                top: itemWidth * food.y,\r\n                backgroundColor: \"green\"\r\n            }}\r\n        >\r\n            <span></span>\r\n        </span>\r\n    )\r\n\r\n}\r\n\r\nconst Snake = memo(({ data, itemWidth }) => {\r\n    return (\r\n        <>\r\n            {data.map((item, index) =>\r\n                <span\r\n                    // key={`${item.x}-${item.y}`}\r\n                    key={index}\r\n                    className=\"boardItem\"\r\n                    style={{\r\n                        position: \"absolute\",\r\n                        width: itemWidth,\r\n                        height: itemWidth,\r\n                        left: itemWidth * item.x,\r\n                        top: itemWidth * item.y,\r\n                        backgroundColor: \"red\"\r\n                    }}\r\n                >\r\n                    <span></span>\r\n                </span>\r\n            )}\r\n        </>\r\n    )\r\n})\r\n```\r\n### App\r\n把各个组件整合起来\r\n```jsx\r\nconst App = () => {\r\n    const size = 20;\r\n    const [ref, { width }] = useMeasure();\r\n\r\n    const itemWidth = width / size;\r\n\r\n    const initialState = {\r\n        isGameOver: false,\r\n        score: 0,\r\n        snake: [\r\n\r\n        ],\r\n        food: null,\r\n        isPaused: true\r\n    }\r\n\r\n    const [state, setState] = useState(initialState);\r\n\r\n    const renderGame = ([snake, isPaused, food, score, isGameOver]) => {\r\n        setState(state => {\r\n            return {\r\n                ...state,\r\n                snake,\r\n                isPaused,\r\n                food,\r\n                score,\r\n                isGameOver\r\n            }\r\n        })\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <Head>\r\n                <link rel=\"stylesheet\" href=\"/styles/greedySnake.css\" />\r\n            </Head>\r\n            {width > 0 ? null : <Loading />}\r\n            <div className=\"snakeGame\" ref={ref} style={{ visibility: width > 0 ? \"visible\" : \"hidden\" }}>\r\n                <Board winWidth={width} size={size} isGameOver={state.isGameOver} />\r\n                <Snake itemWidth={itemWidth} data={state.snake} />\r\n                <Food itemWidth={itemWidth} food={state.food} />\r\n                <div>\r\n                    <button id=\"pauseORresume\">{\r\n                        state.isPaused ? \"START\" : \"PAUSE\"\r\n                    }</button>\r\n                </div>\r\n                <div>\r\n                    <button id=\"reset\">reset</button>\r\n                </div>\r\n                <span>{state.score}</span>\r\n            </div>\r\n        </>\r\n    )\r\n}\r\n```\r\n现在我们已经实现了基本的页面，接下来我们要做的写游戏的逻辑驱动各元素动起来。\r\n\r\n# 实现游戏的逻辑\r\n\r\n### 逻辑总体分析\r\n首先我们分析renderGame方法，可以看到我们需要snake、food、isPaused、isGameover、score5个值来描述游戏的当前状态。那么我们设立5个流snake\\$、food\\$、isPaused\\$、isGameover\\$、score\\$来描述这5个状态，这5个流任何一个更新我们就重刷游戏的状态。那么现在我们的代码看起来应该是这样的。这里我们使用combineLast来获取每个流的最新值，不懂combineLast的可以先去官网看看教程。rxjs的操作符确实博大精深，一个操作符就能实现一个功能，组合起来更加精妙。\r\n```jsx\r\nconst snake$ = of([{x:1,y:1}])\r\nconst food$ = of([{x:4,y:4}])\r\nconst isPaused$ = of(true)\r\nconst isGameOver$ = of(falsse)\r\nconst score$ = of(0)\r\n\r\nconst game$ = combineLatest([snake$, pause$, food$, score$, gameOver$]).pipe(\r\n            takeWhile(([snake, isPaused, food, score, isGameOver]) => !isGameOver, true)\r\n        )\r\n\r\nuseEffect(()=>{\r\n    const sub = game$.subscribe(game => renderGame(game))\r\n    return () => {\r\n        sub.unsubcribe();\r\n    }\r\n})\r\n```\r\n### 实现snake$\r\n\r\n1. 让蛇动起来\r\n首先我们让蛇动起来，很容易就想到interval用每隔一定时间发送一个值然后更新snake$，这里通过一个scan操作符记录上次的结果。scan和reduce很像，只是它处理的不是数组而是一个流。现在每秒发送一个值，然后snake更新x坐标加1，y坐标不变，相当于蛇向右边移动。\r\n```jsx\r\n    const snake$ = interval(1000).pipe(\r\n        scan((snake,_) => {\r\n            //现在我们假设🐍的方向是向右\r\n            let head = snake[0];\r\n            let _x,_y;\r\n            _x = head.x +1;\r\n            _y = head.y;\r\n            return [{x:_x,y:_y}]\r\n        },[{x:1,y:1}])\r\n    )\r\n```\r\n2. 控制蛇的方向\r\n现在蛇可以动了，我们要控制它的方向，通过监听键盘上下左右键，控制蛇的下一个位置.我们加入一个新的流dir\\$,并更新snake\\$。再次强调我们不解释各种操作符的用法，请看注释或者自行学习。\r\n```jsx\r\n    const KEY_EVENTS_DIR = [\r\n        \"ArrowUp\",\r\n        \"ArrowDown\",\r\n        \"ArrowLeft\",\r\n        \"ArrowRight\"\r\n    ]\r\n    const KEY_OPPOSITE = {\r\n        ArrowUp: \"ArrowDown\",\r\n        ArrowDown: \"ArrowUp\",\r\n        ArrowRight: \"ArrowLeft\",\r\n        ArrowLeft: \"ArrowRight\",\r\n    }\r\n    const dir$ = fromEvent(document, \"keydown\").pipe(\r\n        pluck(\"key\"), //从event中取出key\r\n        filter((key) => KEY_EVENTS_DIR.includes(key)), //过滤掉不是方向键的event\r\n        startWith(\"ArrowRight\"), //设置初始方向\r\n        distinctUntilChanged(),  //同一个键盘连续2次不会重复发送\r\n    );\r\n    const snake$ = interval(1000).pipe(\r\n        withLastFrom(dir$),  //每次interval都去取dir的最新值 \r\n        scan((snake,[_,dir]) => {\r\n            let head = snake[0];\r\n            let _x,_y;\r\n            switch (dir) {\r\n                case \"ArrowRight\":\r\n                    _x = _x >= size - 1 ? 0 : _x + 1;\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    _x = _x <= 0 ? size - 1 : _x - 1;\r\n                    break;\r\n                case \"ArrowUp\":\r\n                    _y = _y <= 0 ? size - 1 : _y - 1;\r\n                    break;\r\n                case \"ArrowDown\":\r\n                    _y = _y >= size - 1 ? 0 : _y + 1;\r\n                    break;\r\n            }\r\n            return [{x:_x,y:_y}]\r\n        },[{x:1,y:1}])\r\n    )\r\n```\r\n\r\n现在我们可以通过鼠标控制蛇上下左右自由的移动了。但是我希望在手机上也能玩，可以通过监听touch事件实现。所以我们再加一个手势判断的流gestureDir$。读者应该可以看出现在我们代码逻辑很清晰，一个个简单的功能组成最终的功能，各自完成自己的工作。这就是rxjs的强大之处。想一下我们现在不用rxjs，要实现一个dir\\$的功能，感觉有一大堆代码要写，而且很散乱，没有一定的功力很难写的很漂亮逻辑这么清晰。\r\n\r\n```jsx\r\n     const keyDir$ = fromEvent(document, \"keydown\").pipe(\r\n         pluck(\"key\"),\r\n         filter((key) => KEY_EVENTS_DIR.includes(key)),\r\n         startWith(\"ArrowRight\"),\r\n         distinctUntilChanged(),\r\n     );\r\n\r\n    const gestureDir$ = function () {\r\n        if ('ontouchstart' in document.documentElement) {\r\n            return fromEvent(document, \"touchstart\").pipe(\r\n                switchMap((startEvent) =>\r\n                    fromEvent(document, \"touchmove\").pipe(\r\n                        takeUntil(fromEvent(document, \"touchend\")),\r\n                        takeLast(1),\r\n                        map((event) => {\r\n                            let deltaX = event.touches[0].pageX - startEvent.touches[0].pageX;\r\n                            let deltaY = event.touches[0].pageY - startEvent.touches[0].pageY;\r\n                            if (deltaX > 0 && Math.abs(deltaX) > Math.abs(deltaY)) {\r\n                                return KEY_EVENTS_DIR[3];\r\n                            } else if (deltaX < 0 && Math.abs(deltaX) > Math.abs(deltaY)) {\r\n                                return KEY_EVENTS_DIR[2];\r\n                            } else if (deltaY > 0 && Math.abs(deltaY) > Math.abs(deltaX)) {\r\n                                return KEY_EVENTS_DIR[1];\r\n                            } else {\r\n                                return KEY_EVENTS_DIR[0]\r\n                            }\r\n                        }),\r\n                    )\r\n                )\r\n            )\r\n        }\r\n        return NEVER\r\n    }()\r\n\r\n    const dir$ = merge(keyDir$, gestureDir$);\r\n    \r\n```\r\n3. 让蛇吃苹果变长\r\n   现在蛇可以控制方向4处移动了，但是还不能变长，我们要实现在蛇吃到苹果时长度增加1并且苹果的位置改变。这里有点复杂，因为snake\\$和food\\$相互关联了起来。snake\\$需要拿到当前food\\$的值来判断是否吃到🍎而food\\$也需要拿到snake的值来生成新的位置但不要和snake的位置重叠。我们引入一个新的流eatFood\\$来通知food\\$。\r\n   ```jsx\r\n\r\n    //随机生成食物\r\n   const createFood = (size, data) => {\r\n        let x = Math.floor(Math.random() * size);\r\n        let y = Math.floor(Math.random() * size);\r\n        if (data.some(item => item.x === x && item.y === y)) {\r\n            return createFood(size, data);\r\n        }\r\n        return { x, y }\r\n    }\r\n\r\n    const eatFood$ = new BehaviorSubject([]);\r\n\r\n    const food$ = eatFood$.pipe(\r\n        map(snake => createFood(size, snake)),\r\n        shareReplay(1), //为什么要用shareReplay?\r\n    )\r\n\r\n    const snake$ = interval(1000).pipe(\r\n        withLastFrom(dir$,food$),  //每次interval都去取dir的最新值 \r\n        scan((snake,[_,dir,food]) => {\r\n            let head = snake[0];\r\n            let _x,_y;\r\n            switch (dir) {\r\n                case \"ArrowRight\":\r\n                    _x = _x >= size - 1 ? 0 : _x + 1;\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    _x = _x <= 0 ? size - 1 : _x - 1;\r\n                    break;\r\n                case \"ArrowUp\":\r\n                    _y = _y <= 0 ? size - 1 : _y - 1;\r\n                    break;\r\n                case \"ArrowDown\":\r\n                    _y = _y >= size - 1 ? 0 : _y + 1;\r\n                    break;\r\n            }\r\n            snake.unshift({ x: _x, y: _y });\r\n                //吃到🍎,通知更新food$\r\n            if (food.x === _x && food.y === _y) {\r\n                eatFood$.next(snake) //通知food$更新\r\n            } else {\r\n                snake.pop();\r\n            }\r\n            return [...snake];\r\n        },[{x:1,y:1}])\r\n    )\r\n   ```\r\n4. 增加暂停功能\r\n   现在蛇已经能自由移动，通过吃🍎不断的变长了，游戏的基本逻辑已经实现。接下来我们增加一个暂停和恢复的功能。请注意看pause实现，我们通过switchMap操作符来控制是否往下面的流发送值。\r\n    ```jsx\r\n    const pauseClick$ = fromEvent(document.getElementById(\"pauseORresume\"), \"click\");\r\n\r\n    const pauseKey$ = fromEvent(document, \"keydown\").pipe(\r\n        pluck(\"code\"),\r\n        filter((code) => code === \"Space\")\r\n    )\r\n\r\n    const pause$ = merge(pauseClick$, pauseKey$).pipe(\r\n        startWith(true),\r\n        scan((current, prev) => current ? false : true, false)\r\n    )\r\n\r\n    const interval$ = interval(200);\r\n\r\n    const snake$ = pause$.pipe(\r\n        switchMap((isPaused) => isPaused ? NEVER : inteval$),\r\n        startWith(\"init\"),\r\n        withLastFrom(dir$,food$),  //每次interval都去取dir的最新值 \r\n        scan((snake,[_,dir,food]) => {\r\n            let head = snake[0];\r\n            let _x,_y;\r\n            switch (dir) {\r\n                case \"ArrowRight\":\r\n                    _x = _x >= size - 1 ? 0 : _x + 1;\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    _x = _x <= 0 ? size - 1 : _x - 1;\r\n                    break;\r\n                case \"ArrowUp\":\r\n                    _y = _y <= 0 ? size - 1 : _y - 1;\r\n                    break;\r\n                case \"ArrowDown\":\r\n                    _y = _y >= size - 1 ? 0 : _y + 1;\r\n                    break;\r\n            }\r\n            snake.unshift({ x: _x, y: _y });\r\n                //吃到🍎,通知更新food$\r\n            if (food.x === _x && food.y === _y) {\r\n                eatFood$.next(snake) //通知food$更新\r\n            } else {\r\n                snake.pop();\r\n            }\r\n            return [...snake];\r\n        },[{x:1,y:1}])\r\n    )\r\n   ```\r\n5. 增加gameover判断\r\n现在游戏逻辑基本完成，但是什么时候游戏结束呢，我们还需要实现isGameOver\\$的逻辑，当蛇咬到自己的时候游戏结束，在snake\\$里做判断就行。\r\n```jsx\r\n    const checkGameOver = (snake) => {\r\n        let head = snake[0];\r\n        return snake.slice(1).some(item => item.x === head.x && item.y ===  head.y);\r\n    }\r\n    const snake$ = pause$.pipe(\r\n        switchMap((isPaused) => isPaused ? NEVER : inteval$),\r\n        startWith(\"init\"),\r\n        withLastFrom(dir$,food$),  //每次interval都去取dir的最新值 \r\n        scan((snake,[_,dir,food]) => {\r\n            let head = snake[0];\r\n            let _x,_y;\r\n            switch (dir) {\r\n                case \"ArrowRight\":\r\n                    _x = _x >= size - 1 ? 0 : _x + 1;\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    _x = _x <= 0 ? size - 1 : _x - 1;\r\n                    break;\r\n                case \"ArrowUp\":\r\n                    _y = _y <= 0 ? size - 1 : _y - 1;\r\n                    break;\r\n                case \"ArrowDown\":\r\n                    _y = _y >= size - 1 ? 0 : _y + 1;\r\n                    break;\r\n            }\r\n            snake.unshift({ x: _x, y: _y });\r\n                //吃到🍎,通知更新food$\r\n            if (food.x === _x && food.y === _y) {\r\n                eatFood$.next(snake) //通知food$更新\r\n            } else {\r\n                snake.pop();\r\n            }\r\n            if (checkGameOver(snake)) {\r\n                gameOver$.next(true)\r\n            }\r\n            return [...snake];\r\n        },[{x:1,y:1}])\r\n    )\r\n\r\n```\r\n6. 增加reset功能\r\n游戏结束时我们还需要重置游戏的功能。我们先把之前的逻辑整理成一个方法createGame，然后再增加一个startGame的方法，每次reset就重建一个game\\$达到reset的作用。最终代码如下：\r\n```jsx\r\n        const createGame = () => {\r\n        const gameOver$ = new BehaviorSubject(false);\r\n\r\n        const keyDir$ = fromEvent(document, \"keydown\").pipe(\r\n            pluck(\"key\"),\r\n            filter((key) => KEY_EVENTS_DIR.includes(key)),\r\n            startWith(\"ArrowRight\"),\r\n            distinctUntilChanged(),\r\n        );\r\n\r\n        const gestureDir$ = function () {\r\n            if ('ontouchstart' in document.documentElement) {\r\n                return fromEvent(document, \"touchstart\").pipe(\r\n                    switchMap((startEvent) =>\r\n                        fromEvent(document, \"touchmove\").pipe(\r\n                            takeUntil(fromEvent(document, \"touchend\")),\r\n                            takeLast(1),\r\n                            map((event) => {\r\n                                let deltaX = event.touches[0].pageX - startEvent.touches[0].pageX;\r\n                                let deltaY = event.touches[0].pageY - startEvent.touches[0].pageY;\r\n                                if (deltaX > 0 && Math.abs(deltaX) > Math.abs(deltaY)) {\r\n                                    return KEY_EVENTS_DIR[3];\r\n                                } else if (deltaX < 0 && Math.abs(deltaX) > Math.abs(deltaY)) {\r\n                                    return KEY_EVENTS_DIR[2];\r\n                                } else if (deltaY > 0 && Math.abs(deltaY) > Math.abs(deltaX)) {\r\n                                    return KEY_EVENTS_DIR[1];\r\n                                } else {\r\n                                    return KEY_EVENTS_DIR[0]\r\n                                }\r\n                            }),\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            return NEVER\r\n        }()\r\n\r\n\r\n        const dir$ = merge(keyDir$, gestureDir$);\r\n\r\n        const pauseClick$ = fromEvent(document.getElementById(\"pauseORresume\"), \"click\");\r\n        const pauseKey$ = fromEvent(document, \"keydown\").pipe(\r\n            pluck(\"code\"),\r\n            filter((code) => code === \"Space\")\r\n        )\r\n        const pause$ = merge(pauseClick$, pauseKey$).pipe(\r\n            startWith(true),\r\n            scan((current, prev) => current ? false : true, false)\r\n        )\r\n\r\n        const eatFood$ = new BehaviorSubject([]);\r\n\r\n        const score$ = eatFood$.pipe(\r\n            scan((score, _) => {\r\n                return score + 1\r\n            }, -1)\r\n        )\r\n\r\n        const food$ = eatFood$.pipe(\r\n            map(snake => createFood(size, snake)),\r\n            shareReplay(1),\r\n        )\r\n\r\n        //增加小需求每吃5个苹果速度增加\r\n        const inteval$ = score$.pipe(\r\n            filter(score => score % 5 === 0),\r\n            map(score => {\r\n                let level = Math.floor(score / 5);\r\n                level = level >= 3 ? 3 : level;\r\n                return INTERVAL_TIMES[level];\r\n            }),\r\n            distinctUntilChanged(),\r\n            switchMap((time) => interval(time)),\r\n        )\r\n\r\n        const snake$ = pause$.pipe(\r\n            switchMap((isPaused) => isPaused ? NEVER : inteval$),\r\n            startWith(\"init\"),\r\n            withLatestFrom(dir$, food$),\r\n            //快速切换相反方向导致蛇吃到自己\r\n            scan((prev, [_, dir, food]) => {\r\n                if (KEY_OPPOSITE[dir] === prev[0]) {\r\n                    return [prev[0], food]\r\n                }\r\n                return [dir, food]\r\n            }, []),\r\n            scan((snake, [dir, food]) => {\r\n                let head = snake[0];\r\n                let _x = head.x;\r\n                let _y = head.y;\r\n                switch (dir) {\r\n                    case \"ArrowRight\":\r\n                        _x = _x >= size - 1 ? 0 : _x + 1;\r\n                        break;\r\n                    case \"ArrowLeft\":\r\n                        _x = _x <= 0 ? size - 1 : _x - 1;\r\n                        break;\r\n                    case \"ArrowUp\":\r\n                        _y = _y <= 0 ? size - 1 : _y - 1;\r\n                        break;\r\n                    case \"ArrowDown\":\r\n                        _y = _y >= size - 1 ? 0 : _y + 1;\r\n                        break;\r\n                }\r\n                snake.unshift({ x: _x, y: _y });\r\n                //吃到🍎,通知更新food$\r\n                if (food.x === _x && food.y === _y) {\r\n                    eatFood$.next(snake)\r\n                } else {\r\n                    snake.pop();\r\n                }\r\n                if (checkGameOver(snake)) {\r\n                    gameOver$.next(true)\r\n                }\r\n                return [...snake];\r\n            }, [{ x: 1, y: 1 }]),\r\n        );\r\n\r\n        const game$ = combineLatest([snake$, pause$, food$, score$, gameOver$]).pipe(\r\n            takeWhile(([snake, isPaused, food, score, isGameOver]) => !isGameOver, true)\r\n        )\r\n        return game$;\r\n    }\r\n\r\n\r\n    const renderGame = ([snake, isPaused, food, score, isGameOver]) => {\r\n        setState(state => {\r\n            return {\r\n                ...state,\r\n                snake,\r\n                isPaused,\r\n                food,\r\n                score,\r\n                isGameOver\r\n            }\r\n        })\r\n    }\r\n\r\n    const startGame = () => {\r\n        const reset$ = fromEvent(document.getElementById(\"reset\"), \"click\");\r\n        const game$ = merge(of(\"startGame\"), reset$).pipe(\r\n            switchMap(x => createGame()),\r\n        )\r\n        const sub = game$.subscribe(game => renderGame(game))\r\n        return sub;\r\n    }\r\n\r\n    useEffect(() => {\r\n        let sub = startGame();\r\n\r\n        return () => {\r\n            sub.unsubscribe();\r\n        }\r\n    }, [])\r\n```\r\n\r\n# 总结\r\n\r\n通过写一个贪吃蛇游戏确实加深了我对rxjs的理解，之前我也以为我差不多懂rxjs的用法了。但是真正写的时候为了实现各种需求还是遇到了很多问题。以我写这个demo的经验来看，rxjs真的没有说的那么简单，为了实现不同功能在不同的流之间穿插很考验你对rxjs真正理解的程度。但是不得不承认rxjs真的强大，通过组合各种简单方法实现一个复杂的功能，代码思路清晰逻辑分明，容易扩展和维护。那么到底要不要用rxjs呢?我的观点是一定要比较深入理解rxjs了再用，不然你会遇到很多麻烦的。rxjs可能不像react一样简单，随便看看文档懂了jsx和生命周期就可以动手写了。\r\n\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/3","createdAt":"2021-06-10T16:15:20Z","tags":[{"name":"react","color":"8E26BB"}],"description":"本文主要介绍使用rxjs和react实现一个经典的贪吃蛇游戏。","keywords":["rxjs","游戏","贪吃蛇"]},{"id":"ef06e5380fa3c72d3c8d31deda624cd5","title":"使用javascript生成pdf文件","body":"一个教育网站项目有个需求，需要在学员完成某些测试后生成证书并下载。本以为应该是调用后端的接口生成，但是后端也说不太懂，只好前端来研究一下解决方案。google一下后发现比较靠谱的有2种方案。\r\n\r\n- 使用jspdf和html2canvas这2个库在前端实现\r\n- 使用nodejs通过puppeteer 在后端生成\r\n\r\n下面分别说说这2种方法的实现。\r\n\r\n# 使用jspdf生成pdf\r\n\r\n\r\n首先编写pdf模版的html(我这里是用react写的)。\r\n```jsx\r\n<Cert\r\n    chineseName={chineseName}\r\n    englishName={englishName}\r\n    unitInfo={unitInfo}\r\n/>\r\n```\r\n因为这个模版只是用来生成pdf，并不用显示，所以通过css将其放在视野之外。\r\n```css\r\n.cert {\r\n    width: 870px;\r\n    height: 615px;\r\n    position: absolute;\r\n    // background:transparent url($imgData) ;\r\n    // background-size: 100%;\r\n    // top:-30px;\r\n    left: 5000px;\r\n    visibility: hidden;\r\n    z-index: 99;\r\n}\r\n```\r\n核心代码,先用html2canvas将html转成canvas，再将canvas转成image dataurl，再将image写入pdf中。\r\n```jsx\r\nconst savePDF = async () => {\r\n    setIsLoading(true);\r\n    try {\r\n        const jsPDF = (await import(\"jspdf\")).default; //引入jspdf\r\n        const html2canvas = (await import(\"html2canvas\")).default; //引入html2canvas\r\n        let canvas = await html2canvas(document.querySelector(\"#cert\"), {\r\n            scrollY: 0,  //不设置此属性 滚动视图时会导致下载的pdf有部分不显示\r\n            onclone: (clonedDoc) => {\r\n                clonedDoc.getElementById(\"cert\").style.visibility = 'visible'; //将pdf模版设为可见\r\n            }\r\n        })\r\n        var imgData = canvas.toDataURL('image/png');\r\n        var doc = new jsPDF('l', 'mm', \"a4\", true); \r\n        var width = doc.internal.pageSize.getWidth();\r\n        var height = doc.internal.pageSize.getHeight();\r\n        doc.addImage(imgData, 'PNG', 0, 0, width, height, \"\", \"FAST\"); //FAST 是否压缩\r\n        // let pdf = doc.output('blob');\r\n        // let form = new FormData();\r\n        doc.output('save', 'Certificate.pdf');\r\n    } catch (err) {\r\n        console.log(err);\r\n    } finally {\r\n        setIsLoading(false)\r\n    }\r\n}\r\n```\r\n这就大功告成了？高兴的太早！😭😭😭问题总是层出不穷的多。在用此方法中一共遇到三个较大的问题。\r\n\r\n1. 初步实现功能提交后，一天qa突然和我说怎么生成的pdf上半部分是空白的。没办法，找找找。通过google，发现是html2canvas时会根据用户滚动的位置来计算的，设置scrollY: 0解决。\r\n2. 之前在dev场中测试并没有发现问题，但是上了uat后发现pdf中图片没加载。最后发现是因为uat场图片全部放在了cdn的缘故，pdf不会加载非同源站的图片也就跨域，设置useCORS也没有用。最后直接把pdf中用到的图片换成base64解决。\r\n3. 不同的浏览器和设备生成的pdf文件size不同。有的只有几M,有的十几M。这个应该和设备的分辨率有关。设置了是否压缩，可以调节pdf的size，但是还是无法统一生成的pdf的size。\r\n\r\n# 使用puppeteer后端生成pdf \r\n\r\n做过爬虫的应该都听过鼎鼎大名的phantomjs，当年这个库很火，可以说是一些比较复杂网站的爬虫最终解决方案。因为它可以让你用js操作一个真正的浏览器去访问网站。puppeteer是google推出的headless chrome，可以说是phantomjs的替代品，自从这个库出世，phantomjs好像就停止维护了。\r\n\r\n>  Puppeteer is a Node library which provides a high-level API to control Chrome or Chromium over the DevTools Protocol. Puppeteer runs headless by default, but can be configured to run full (non-headless) Chrome or Chromium.\r\n\r\n为了解决上面说的不同设备生成的pdf size不同的问题，我们可以使用puppeteer来在后端生成pdf。\r\n因为生成的证书如姓名成绩之类的是动态的，所以要用模版动态生成，因为我的项目是react，所以直接用jsx生成模板，用rendertostring生成html字符串。也有一些style和图片处理比较麻烦，可以看我代码，但是这里只是简单实现。\r\n\r\n```jsx\r\nconst PdfTemplate = ({ imgSrc }) => {\r\n    return (\r\n        <div className=\"bg\">\r\n            <h2>heading</h2>\r\n            <div>\r\n                content\r\n            </div>\r\n            <img src={imgSrc} alt=\"\" style={{ width: \"100%\", height: 300 }} />\r\n        </div>\r\n    )\r\n}\r\n\r\nconst createHtmlStr = () => {\r\n    const imagePath = __dirname + \"/../../../../public/images/bg.jpeg\";\r\n    const imgData = fs.readFileSync(imagePath).toString(\"base64\");\r\n    const imgSrc = `data:image/jpeg;base64,${imgData}`;\r\n    const content = ReactDOMServer.renderToString(<PdfTemplate imgSrc={imgSrc} />)\r\n    return `\r\n        <html>\r\n            <head>\r\n                <style>\r\n                    html,body{\r\n                        margin:0;\r\n                        padding:0;\r\n                        height:100%\r\n                    }\r\n                    .bg{\r\n                        height:100%;\r\n                        position:relative;\r\n                    }\r\n                </style>\r\n            </head>\r\n            <body>\r\n                ${content}\r\n            </body>\r\n        </html>\r\n    `\r\n}\r\n```\r\n后端代码\r\n```javascript\r\nexport default async function handler(req, res) {\r\n    console.log(\"start\")\r\n    const browser = await puppeteer.launch({\r\n        args: ['--disable-dev-shm-usage', '--no-sandbox']\r\n    });\r\n    const page = await browser.newPage();\r\n    ;\r\n    const html = createHtmlStr();\r\n    console.log(html, \"====\")\r\n    // await page.goto(\"http://localhost:3000/\");\r\n    await page.setContent(html);\r\n    const pdf = await page.pdf({\r\n        format: 'A4',\r\n        printBackground: true,\r\n        '-webkit-print-color-adjust': 'exact',\r\n    });\r\n    await browser.close();\r\n    console.log(\"end render\");\r\n    res.setHeader(\"Content-Type\", 'application/pdf');\r\n    res.status(200);\r\n    res.send(pdf);\r\n}\r\n\r\n```\r\n前端代码\r\n```javascript\r\n  const downloadPDF = async () => {\r\n          let response = await fetch(\"/api/createPdf\", {\r\n              responseType: 'arraybuffer',\r\n              headers: {\r\n                  'Accept': 'application/pdf'\r\n              }\r\n          });\r\n          let blob = await response.blob();\r\n          // const blob = new Blob([response.body], { type: 'application/pdf' })\r\n          const link = document.createElement('a')\r\n          link.href = window.URL.createObjectURL(blob)\r\n          link.download = `your-file-name.pdf`\r\n          link.click()\r\n  }\r\n```\r\n# 总结\r\n\r\n1. 在前端通过截屏html元素生成pdf，简单方便，不需要后端配合，直接在前端生成pdf，缺点就是生成的pdf文件大小不统一。\r\n2. 在后端用puppeteer生成pdf，可以解决上述方法的问题，但是要引入一个新的接口，需要加一个node服务，这个项目因为我们是用nextjs写的，所以可以很方便的加一个api接口。但是一般我们的后端都是java写的，要额外的开一个node服务不是特别方便。\r\n\r\n","url":"https://github.com/gwl002/gwl002.github.io/issues/2","createdAt":"2021-06-06T14:54:27Z","tags":[{"name":"工作经验","color":"bfdadc"}]}],"tags":[{"name":"javascript","color":"1d76db"},{"name":"react","color":"8E26BB"},{"name":"css","color":"F49416"},{"name":"工作经验","color":"bfdadc"},{"name":"react-native","color":"5319e7"}],"title":"标签","subTitle":"把文章按标签整理分类"},"__N_SSG":true}